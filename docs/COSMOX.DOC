



      _____                                __    __
     /     \        ____                  /  .  .  \
    |  ..   |_____ /    \ ___  ___  _____/\   \/   /        ____      ___
   ||  ||__/`  _  |   __/'   \/   \/  _  \ \      /    _ _ /    \    /   \
   ||  ||  \| | | |.__  \|        || | | |\/      \   | | ||_/  /   |  |  |
   ||  ''   | |_| |Ô     |  |  |  || |_| |/   /\   \  |   | /  /_   |  |  |
   | \_____/`_____'\____/`_/'\/'\_'`_____'\__'\ `__/   \ / |_____|[] \___/
    \_____/`_____'\____/`_/'\/'\_'`_____'\__'  `__/     '


                         Version 2.0   October/2001




        ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
        ≥   CosmoX is a game programming library for QuickBASIC 4.5   ≥€
        ≥                 by bobby - CosmoSoft 2000-2001              ≥€
        ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ€
           ﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂﬂ

               [Note : This document is best viewed in a DOS editor]


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - DISCLAIMER -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

    I AM NOT RESPONSIBLE FOR ANY DAMAGES, PERMANENT OR TEMPORARY, THAT ARE
    CAUSED TO YOU OR ANYTHING RELATED TO YOU BY COSMOX. I HAVE CHECKED COSMOX
    TO MAKE SURE IT IS FREE OF SERIOUS BUGS, BUT THERE IS ALWAYS A POSSIBILITY
    THAT SOME EXIST. IF YOU FIND ANY BUGS IN COSMOX PLEASE E-MAIL A DETAILED
    DESCRIPTION OF WHAT HAPPENED AND WHAT ERROR MESSAGE (IF ANY) WAS DISPLAYED
    ON THE SCREEN TO : BOBBY3999@YAHOO.COM, AND I WILL CORRECT THEM.


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Index -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

  1 - Introduction
    1.1 Introduction to the library
    1.2 Features
    1.3 History and changes
  2 - General Info
  3 - Functions reference (the routines are in alphabetical order)
      - FUNCTION CSAllocateEMS
      - FUNCTION CSAllocateXMS
      - FUNCTION CSAsc
      - FUNCTION CSBin
      - FUNCTION CSBinToDec
      - FUNCTION CSChdir
      - FUNCTION CSCheckKeys
      - FUNCTION CSClearBit
      - FUNCTION CSCollide
      - FUNCTION CSCollision
      - FUNCTION CSCollisionC
      - FUNCTION CSCpuId
      - FUNCTION CSCreateBMap
      - FUNCTION CSDetectCPU
      - FUNCTION CSDetectEMS
      - FUNCTION CSDetectMMX
      - FUNCTION CSDetectMouse
      - FUNCTION CSDetectWin
      - FUNCTION CSDetectXMS
      - FUNCTION CSDrive
      - FUNCTION CSEMSHandles
      - FUNCTION CSEMSVersion
      - FUNCTION CSElapsedTicks
      - FUNCTION CSFindCol
      - FUNCTION CSFindFile
      - FUNCTION CSFreeDiskSpc
      - FUNCTION CSFreeEMS
      - FUNCTION CSFreeEMSPages
      - FUNCTION CSFreeXMS
      - FUNCTION CSGetBMap
      - FUNCTION CSGetCard
      - FUNCTION CSGetEMSFrame
      - FUNCTION CSGetTextSpacing
      - FUNCTION CSId
      - FUNCTION CSInitBlaster
      - FUNCTION CSKey
      - FUNCTION CSLen
      - FUNCTION CSLoadBMP
      - FUNCTION CSLoadBMap
      - FUNCTION CSLoadFont
      - FUNCTION CSLoadPCX
      - FUNCTION CSLoadPal
      - FUNCTION CSLoadRawSound
      - FUNCTION CSLoadWavSound
      - FUNCTION CSMouseClickOn
      - FUNCTION CSMouseLB
      - FUNCTION CSMouseOver
      - FUNCTION CSMouseRB
      - FUNCTION CSMouseX
      - FUNCTION CSMouseY
      - FUNCTION CSPath
      - FUNCTION CSPeek
      - FUNCTION CSPeek16
      - FUNCTION CSPeek32
      - FUNCTION CSPoint
      - FUNCTION CSPolyFacing
      - FUNCTION CSProcessor
      - FUNCTION CSReadBit
      - FUNCTION CSReadKey
      - FUNCTION CSResizeEMS
      - FUNCTION CSResizeXMS
      - FUNCTION CSRotateL
      - FUNCTION CSRotateR
      - FUNCTION CSSaveBMP
      - FUNCTION CSSaveBMap
      - FUNCTION CSSavePal
      - FUNCTION CSSetBit
      - FUNCTION CSShiftL
      - FUNCTION CSShiftR
      - FUNCTION CSSize
      - FUNCTION CSSnapShot
      - FUNCTION CSSoundDone
      - FUNCTION CSTimerFlag
      - FUNCTION CSTimerTicks
      - FUNCTION CSToggleBit
      - FUNCTION CSTotalDiskSpc
      - FUNCTION CSTotalDrives
      - FUNCTION CSTotalEMS
      - FUNCTION CSTotalEMSPages
      - FUNCTION CSTotalXMS
      - FUNCTION CSVectorDot
      - FUNCTION CSVer
      - FUNCTION CSWinAppGetTitle
      - FUNCTION CSWinChdir
      - FUNCTION CSWinDelFile
      - FUNCTION CSWinFindFile
      - FUNCTION CSWinFindNext
      - FUNCTION CSWinGetClipBDataSize
      - FUNCTION CSWinGetClipBDataType
      - FUNCTION CSWinGetVMID
      - FUNCTION CSWinMakeDir
      - FUNCTION CSWinOpenClipB
      - FUNCTION CSWinPath
      - FUNCTION CSWinRemoveDir
      - FUNCTION CSWinVMGetTitle
      - FUNCTION CSXAllocateXMS
      - FUNCTION CSXFreeXMS
      - FUNCTION CSXMSHandles
      - FUNCTION CSXMSVersion
      - FUNCTION CSXNormal
      - FUNCTION CSXResizeXMS
      - FUNCTION CSXTotalXMS
      - FUNCTION CSYNormal
      - FUNCTION CSZNormal
      - SUB CSAntiAliase
      - SUB CSBlackPal
      - SUB CSBox
      - SUB CSBoxF
      - SUB CSBoxFB
      - SUB CSButton
      - SUB CSCircle
      - SUB CSCircleF
      - SUB CSClear
      - SUB CSClearMMX
      - SUB CSClose
      - SUB CSContinueSound
      - SUB CSCopyBlock
      - SUB CSCopyMatrix
      - SUB CSDeallocateEMS
      - SUB CSDeallocateXMS
      - SUB CSDelay
      - SUB CSDestroyBMap
      - SUB CSEllipse
      - SUB CSEllipseF
      - SUB CSFadeIn
      - SUB CSFadeInStep
      - SUB CSFadeTo
      - SUB CSFadeToStep
      - SUB CSFfix
      - SUB CSFire
      - SUB CSGet
      - SUB CSGetClipBox
      - SUB CSGetCol
      - SUB CSGetFont
      - SUB CSGetPal
      - SUB CSGradientPal
      - SUB CSGrayPal
      - SUB CSIdentityMatrix
      - SUB CSInitRotXMatrix
      - SUB CSInitRotYMatrix
      - SUB CSInitRotZMatrix
      - SUB CSInitScaleMatrix
      - SUB CSInitText
      - SUB CSInitTransMatrix
      - SUB CSInitVGA
      - SUB CSInstallKeyBoard
      - SUB CSInstallTimer
      - SUB CSLine
      - SUB CSLockKeys
      - SUB CSMakePhongPal
      - SUB CSMapEMS
      - SUB CSMapEMSLayer
      - SUB CSMatrixMulMatrix
      - SUB CSMemCopy
      - SUB CSMemCopyMMX
      - SUB CSMemSwap
      - SUB CSMemSwapMMX
      - SUB CSMouseOff
      - SUB CSMouseOn
      - SUB CSMoveEMS
      - SUB CSMoveFromEMS
      - SUB CSMoveFromXMS
      - SUB CSMoveToEMS
      - SUB CSMoveToXMS
      - SUB CSMoveXMS
      - SUB CSNegativePal
      - SUB CSPauseSound
      - SUB CSPcopy
      - SUB CSPcopyB
      - SUB CSPcopyC
      - SUB CSPcopyMMX
      - SUB CSPcopyT
      - SUB CSPlaySound
      - SUB CSPoke
      - SUB CSPoke16
      - SUB CSPoke32
      - SUB CSPrint
      - SUB CSPrintBlended
      - SUB CSPrintBold
      - SUB CSPrintReversed
      - SUB CSPrintShadow
      - SUB CSPrintSolid
      - SUB CSPrintTextured
      - SUB CSProjectVector
      - SUB CSPset
      - SUB CSPsetB
      - SUB CSPushButton
      - SUB CSRemoveFfix
      - SUB CSRemoveKeyBoard
      - SUB CSRemoveTimer
      - SUB CSResetFont
      - SUB CSResetMouse
      - SUB CSResetTicks
      - SUB CSRotatePalB
      - SUB CSRotatePalF
      - SUB CSScroll
      - SUB CSScrollArea
      - SUB CSScrollHEMS
      - SUB CSScrollVEMS
      - SUB CSSetBMap
      - SUB CSSetClipBox
      - SUB CSSetCol
      - SUB CSSetDrive
      - SUB CSSetFont
      - SUB CSSetMouseCursor
      - SUB CSSetMouseRange
      - SUB CSSetMouseSpeed
      - SUB CSSetMouseXY
      - SUB CSSetPal
      - SUB CSSetTextSpacing
      - SUB CSSetTimer
      - SUB CSSort
      - SUB CSSprite
      - SUB CSSpriteB
      - SUB CSSpriteC
      - SUB CSSpriteF
      - SUB CSSpriteFlipH
      - SUB CSSpriteFlipV
      - SUB CSSpriteFlipped
      - SUB CSSpriteN
      - SUB CSSpriteO
      - SUB CSSpriteR
      - SUB CSSpriteRZ
      - SUB CSSpriteS
      - SUB CSTextTexture
      - SUB CSTextureWidth
      - SUB CSTri
      - SUB CSTriF
      - SUB CSTriFB
      - SUB CSTriG
      - SUB CSTriGB
      - SUB CSTriT
      - SUB CSTriTB
      - SUB CSTriTF
      - SUB CSTurnBlasterOff
      - SUB CSTurnBlasterOn
      - SUB CSUnitVector
      - SUB CSVectorMulMatrix
      - SUB CSWaitKey
      - SUB CSWaitRetrace
      - SUB CSWaitTimer
      - SUB CSWin
      - SUB CSWinAppSetTitle
      - SUB CSWinCloseClipB
      - SUB CSWinEmptyClipB
      - SUB CSWinFindClose
      - SUB CSWinGetClipBData
      - SUB CSWinSetClipBData
      - SUB CSWinVMSetTitle
      - SUB CSWindow
  4 - EMS Memory
  5 - XMS Memory
  6 - Blender maps
  7 - Using the timers
  8 - Using MMX routines
  9 - Library constants
 10 - Library types
 11 - Library formats
 12 - Credits and final words

ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Introduction -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  Introduction to the library  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  CosmoX is a graphic and game programming library written in 386 assembly
  language for QuickBASIC 4.5. It has been coded to give QuickBASIC
  programmers an option to make their graphics programs faster and better.
  It works in mode 13h (SCREEN 13). If you use this library it would be nice
  if you put my name and my web site url somewhere in your program. Give
  credit were credit is due. Also it would be cool if you send me a copy of
  your work.

  I developed this library because I always look for better performance, and,
  well, QB just doesn't make the grade, it is slow as hell, and when I was
  trying to use other people's libraries they just didn't suit my needs, or I
  didn't like the interface, or they were slow and very unoptimized so I just
  had to make my own library, and CosmoX was born.
  I really made it the fastest I could, and I added lot of cool things so I
  think you won't be disappointed.


  - NOTE -
  SINCE COSMOX V1.1, SOME ROUTINES THAT TAKE STRINGS AS INPUT OR OUTPUT
  MANAGE THE QB STRING DESCRIPTORS (QB CONTROLS STRINGS WITH THEM) THEMSELVES,
  THIS CAN KEEP COSMOX FROM WORKING ON QB 7.1 (PDS) DUE TO DIFFERENT
  DESCRIPTOR FORMAT. (JUST A FEW ROUTINES)

  I hope you enjoy using this library as I enjoyed coding it!!.

                                                                   bobby.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  Features  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  - Graphics features -

  -  It supports 320x200 in 256 colors video mode.
  -  It supports drawing to offscreen buffers.
  -  It has many graphical primitives like Pset, Line, Circle, Box, etc.
  -  Very fast sprite routines supporting scaling, transparency, flipping,
     rotating, roto-zooming, etc.
  -  The sprite format is QuickBASIC GET-PUT compatible.
  -  Sprite collision detection.
  -  Loads BMP and PCX files. Also can save in BMP format.
  -  Color blending allowing any color combination.
  -  Font routines with customizable font set and several drawing styles.
  -  A lot of palette handling routines.
  -  Multi directional scrolling of a selected area or an entire layer.
  -  Very fast triangle drawing routines. Including flat-shading, gouraud-
     shading, and affine texture mapping.
  -  Several windowing routines.


  - Input features -

  -  Custom keyboard interrupt handler that allows reading the state of.
     multiple keys at any moment.
  -  Several keyboard routines that work under the custom handler.
  -  Several mouse routines, supporting changes to the cursor shape, speed,
     range, etc. Also, the mouse position and status is updated automatically.
     when the user moves the mouse or presses a button.


  - Sound features -

  -  CosmoX supports 8-bit mono sounds through the sound card. It can load
     .WAV files, just one sound at a time.


  - Misc features -

  -  Full interaction with the Windows clipboard!!!, you can read and write
     to it very easily, wanted to communicate with Windows? now is the time!
  -  Support for Windows long file names, now you can search for files using
     long filenames, you can create, remove and change directories using long
     file names, plus, you can delete files too.
  -  MMX instruction support to speed up commonly used routines.
  -  16 high precision timers so you can time any kind of thing within your
     programs with ease!!.
  -  Full XMS and EMS support to create offscreen buffers and to store all
     kind custom data.
  -  XMS can use Super Extended Memory calls, so now XMS isn't limited to 64 MB
     now you can allocate all the memory in the system!!..
  -  Bit handling routines including shifting, setting, clearing, toggling, etc.
  -  Directory scanning routines.
  -  Fast sorting of records.
  -  Advanced CPU detecting routines.
  -  Matrix calculation routines that uses the FPU to allow fast 3D vector
     graphics (no more QB slow floating-point emulation!!!).


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  History and changes  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  This is a short summary of CosmoX updates.


  * CosmoX v2.0 - October 2001

  - 250 routines.
  - At least, made a big update, you did think that I was dead, didn't you?
  - Added lot of routines that interact with Windows!, you can now read and
    write to the Windows clipboard, search files using long filenames, plus
    other goods that you'll find out.
  - Added CSDetectWin, CSWinAppGetTitle, CSWinChdir, CSWinDelFile,
    CSWinFindFile, CSWinFindNext, CSWinGetClipBDataSize, CSWinGetClipBDataType,
    CSWinGetVMID, CSWinMakeDir, CSWinOpenClipB, CSWinPath, CSWinRemoveDir,
    CSWinVMGetTitle, CSWinAppSetTitle, CSWinCloseClipB, CSWinEmptyClipB,
    CSWinFindClose, CSWinGetClipBData, CSWinSetClipBData, CSWinVMSetTitle.
  - Added CSMemCopyMMX that copies a memory region to another using MMX
    instructions to boost up the operation.
  - Added CSMemSwapMMX that swaps a memory region with another using MMX
    instructions to boost up the operation.
  - Added CSFire that gives a nice fire effect if used with the right
    palette.
  - Optimized some palette routines.
  - Fixed a little bug on CSSpriteRZ that was drawing garbage sometimes,
    but, I noticed that on some sprite heights (odd ones) it wont draw
    the last sprite scanline, so have that in mind. (Thanks goes to
    Lithium for reporting this bug)
  - Added new constants and TYPEs definitions.
  - CHANGED SOME CONSTANTS NAMES, SO PLEASE CHECK THIS OUT BECAUSE IT CAN
    MAKE SOME HARD TO FIND BUGS WHEN RECOMPILING OLD COSMOX APPS CODE THAT
    USE THEM, PLEASE DON'T GET MAD, I JUST MADE THEM MORE READABLE, THANKS.


  * CosmoX v1.7 - April 2001

  - 226 routines.
  - Rewrote CSSprite and CSSpriteB, they are now faster than ever!.
  - Added CSSpriteN, it draws the sprite clipping it against the clipping box
    but it doesnt check for color-0 transparency, which makes it very fast!.
  - Added CSScrollHEMS and CSScrollVEMS, they produce a horizontal and vertical
    scrolling effect respectively, using backgrounds stored on EMS. If you
    are a little smart, you can create a cool side-scroller game very easily
    using this routines.
  - Added CSFfix and CSRemoveFfix, the first one fixes a bug located on
    QuickBASIC code that makes programs using floating point instructions too
    slow, with this fixup your programs can get 300% faster on floating point
    operations!!. CSRemoveFfix removes this fixup, and must be called before
    the program exits (CSClose calls it too, so if you use this routine at the
    end of your program then you won't have to worry about it).
  - Fixed a bug on CSLoadBMP and CSSaveBMP, they couldn't process BMPs with a
    non-multiple of 4 width, now they can without problems =)
  - Fixed a bug on CSTriF, it drew some pixels out of the clipping box.


  * CosmoX v1.6 - March 2001

  - 221 routines.
  - Added CSSpriteR at least! a sprite rotation routine!.
  - Added CSSpriteRZ a sprite rotation routine too. But it also scales!!!.
    A roto-zooming routine!.


  * CosmoX v1.5 - March 2001

  - 219 routines.
  - Rewritten the CSLine routine, it has more reliable clipping now.
  - Changed CSVectorMulMatrix, the destiny vertex can be the same as the
    source one.
  - Added CSPsetB, it works like CSPset, but it blends the color with the
    background.
  - Added CSBoxFB, it works like CSBoxF, but it blends the color with the
    background.
  - Changed CSBox and CSBoxF, they don't need x1 < x2 and y1 < y2 anymore!.
  - This version is Lithium's special edition =) (because I built it specially
    for him)


  * CosmoX v1.4 - February 2001

  - 217 routines.
  - Optimized some routines
  - Fixed bugs, a very nasty bug in CSSetClipBox set ClipX2 to 399, at least
    it was very hard to make this bug happen. (And now it is fixed).
    Also fixed bug in 3D filling subs, they behaved strangely when the
    triangle was completely out of clipping box. Now they work right =)
    Fixed bug in CSSpriteF, it calculated the X on a wrong way. Fixed too.
  - Added CSXMSHandles, it returns the number of free XMS handles.
  - Added CSProcessor, it returns a little string that holds the CPU present
    in the system.
  - Since CosmoX v1.2 CSInstallKeyBoard and CSRemoveKeyBoard were converted to
    sub instead of functions, and I forgot to mention it. Sorry =(
  - Fixed some mistakes in the documentation. (Again)


  * CosmoX v1.3 - January 2001

  - 215 routines.
  - Added MMX support!!!!!. Added new routines that uses MMX instructions to
    speed up commonly used routines!!!
  - Added CSClose, it removes the timer, the keyboard, destroys the blender
    map and sets text mode, all in just one routine.
  - Added CSPeek and CSPoke, they work the same as QB PEEK and POKE, but they
    are more flexible.
  - Added CSCpuId, it returns a little string holding the CPU vendor name.
  - CSDetectCPU rewritten, it can check now for Pentium, Pentium Pro and higher
    processors.
  - Fixed bug in timer code, CSElapsedTicks didn't return the high word of the
    counters.
  - Optimized the library even more.
  - Optimized the base 3D filling routines a lot!, now CSTriF, CSTriG, CSTriT
    are like 90% faster!.
  - Fixed some mistakes in the documentation. Opps =)


  * CosmoX v1.2 - January 2001

  - 208 routines.
  - Added a very cool high precision timer, you can have up to 16 timers, all
    running at different speeds, now you can time whatever you want, like:
    frame rate, numbers of frames, number of seconds your program has running,
    etc,. The beauty of this thing is that Windows won't complain about it!!!.
  - CSEllipse and CSEllipseF totally rewritten!!!!. They now have a improved
    algorithm that allows drawing bigger ellipses than before!!!. CSCircle
    and CSCircleF are now wrappers to CSEllipse and CSEllipseF.
  - Removed CSArcCircle and CSArcEllipse, they just didn't make sense and the
    new algorithm in CSCircle and CSEllipse wouldn't allow me to do it.
  - Rewritten the inner loop of CSTriF, it is now faster than ever.
  - Optimized some routines.


  * CosmoX v1.1 - January 2001

  - 203 routines. <------- Wow!!!
  - Optimized a bunch of routines
  - Fixed that bug in CSSoundDone, it now must work in every system.
  - Added CSMakePhongPal which uses the phong illumination model to calculate
    a palette to use with gouraud shading (CSTriG), this thing really can
    create very cool palettes.
  - Converted CSBin and CSBinToDec to assembly language (they were coded in
    BASIC) and now they manage the string descriptors, so there aren't
    function overrides.
  - Added CSTriTF which draws a textured triangle, but applying bilinear
    filtering, which smoothes the texture aliasing. (It needs a gradient
    palette to work correctly, see COSMOX.DOC for notes about this sub).
  - Changed CSCreateBMap, now you don't have to call SETMEM(-66000) because
    now the sub calls the BASIC memory manager itself. Cool!!!.
  - Now added support for Extended XMS, with this you can access to all the
    memory on your system through XMS!!!. The limit of normal XMS is 64 MB.
    (Use the normal routines if you don't need to access all the memory)
  - Rewrote CSXNormal, CSYNormal, CSZNormal so they now return the value
    themselves (they used a QB function to return the value)
  - CSId now rewritten in assembly.
  - Added CSCopyBlock which copies a given rectangle between 2 layers, this
    can be used to restore a background without copying the whole layer.


  * CosmoX v1.0 - December 2000 (First release)

  - 196 routines.
  - Finally get out to the public (I have like 7 or 8 months working on this)
  - Lots of routines to handle EMS, XMS, PALETTES, SPRITES, DRAWING
    PRIMITIVES, TRIANGLE FILLING, COLOR BLENDING, SOUND BLASTER, BIT
    MANIPULATION, DIRECTORY SCAN, FONTS, BMP AND PCX IMAGE FILES, KEYBOARD
    MEMORY ACCESS, MOUSE HANDLING, MATRIX CALCULATION, BMP AND PCX FILES, etc.


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - GENERAL INFO -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ


    To get CosmoX running you have to tell QuickBASIC to load it, you achieve
    this by putting the files COSMOX.LIB and COSMOX.QLB in your QB library
    folder, just put them where you see the file QB.LIB and QB.QLB, next put
    COSMOX.BI in your include folder, again just search for the file QB.BI,
    Or you can put them on the same directory where your project resides.

    Then just type :

    QB /L COSMOX

    This tells QuickBASIC to use CosmoX when running from the IDE or
    compiling.

    Now just make sure to put this on the top of your program :

    REM $INCLUDE : 'COSMOX.BI'

    Now you are ready to use CosmoX routines!!


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - FUNCTIONS REFERENCE -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSAllocateEMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSAllocateEMS% (BYVAL Pages%)


Parameters:

  - Pages        Number of logical pages to allocate from EMS


Returns:

  A EMS handle that you need to continue operating this memory and to free it.


Description:

  This function allocates the given number of logical pages from EMS, each
  logical page is 16K, so to create a layer you need to allocate 4 logical
  pages (64K). This function is very useful to create layers, but can be used
  to store any kind of data.
  Always remember to check if there is EMS memory with CSDetectEMS so you can
  safely use the EMS routines.
  Don't forget to deallocate any memory you allocate with CSDeallocateEMS or
  you are going to create a memory leak and that memory won't be accessible
  until the machine is rebooted.
  If you don't know what's EMS refer to EMS Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSAllocateXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSAllocateXMS% (BYVAL KB&)


Parameters:

  - KB          Number of KB to allocate from XMS


Returns:

  A XMS handle that you need to continue operating this memory and to free it.


Description:

  This function allocates a given number of KB from XMS, XMS is useful to
  store to store custom data like sprites and tables, but because the system
  it uses it's not so useful to create layers, to create layers better use EMS.
  Always remember to call CSDetectXMS before any XMS routine, if you fail
  to do this your computer is likely to crash.
  Don't forget to deallocate any memory you allocate with CSDeallocateXMS or
  you are going to create a memory leak and that memory won't be accessible
  until the machine is rebooted.
  If you don't know what's XMS refer to XMS section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSAsc FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSAsc% (BYVAL ScanCode%, BYVAL Shift%)


Parameters:

  - ScanCode       Key scancode to retrieve the code from
  - Shift          Shift state



Returns:

  An INTEGER holding the ascii code of the given scancode.


Description:

  This function returns the ascii code of the given scancode, but like
  some scan codes may have several ascii codes (like the character keys, for
  example : "B" and "b") you have to specify the shift state, this is, if
  you give 0 you'll get a "b" (for example) and if you give 1 you'll get
  a "B".


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSBin FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSBin$ (Value%)


Parameters:

  - Value        The value to convert to binary


Returns:

  A string representing the binary representation of Value


Description:

  Always wanted to know how is represented a number in binary system?


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSBinToDec FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSBinToDec% (Number$)


Parameters:

  - Number        A 16 bytes string representing a binary number


Returns:

  The decimal value of Number


Description:

  This is the inverse of the last function, this gives you a decimal of a
  binary string.
  This function only accepts "1" and "0" in the string, if you give other
  character you will get a wrong answer.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSChdir FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSChdir% (NewDir$)


Parameters:

  - NewDir         A string holding the new directory path


Returns:

  0  if successful
 -1  if error


Description:

  This function sets the current directory. If the path includes a drive
  letter this function will change the directory on that drive, but it won't
  change the current drive. It returns 0 if successful and -1 if is an invalid
  drive.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCheckKeys FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSCheckKeys% ()


Returns:

  An INTEGER holding the key pressed (0 if none).


Description:

  This sub checks if there is a key pressed in the keyboard buffer. The
  difference with other routines is that this one doesn't wait for a keypress,
  it checks the keyboard and returns the key scancode if a key is pressed,
  zero otherwise.
  If there is a key pressed, this sub waits till it gets released.
  This sub works with the custom keyboard handler only.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSClearBit FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSClearBit% (BYVAL Value%, BYVAL Bit%)


Parameters:

  -  Value         Value to clear the bit on
  -  Bit           Bit number (0-15)


Returns:

  The new value with the bit clear.


Description:

  This function clears the bit specified in Bit to Value and returns it.
  The bits are zero relative, so an INTEGER has 0-15 bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCollide FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSCollide% (BYVAL X1%, BYVAL Y1%, BYVAL Segment1%, BYVAL Offset1%, BYVAL X2%, BYVAL Y2%, BYVAL Segment2%, BYVAL Offset2%)


Parameters:

  -  X1            The upper left X position of the first sprite
  -  Y1            The upper left Y position of the first sprite
  -  Segment1      Segment of the array holding the first sprite (Use VARSEG)
  -  Offset1       Offset of the array holding the first sprite (Use VARPTR)
  -  X2            The upper left X position of the second sprite
  -  Y2            The upper left Y position of the second sprite
  -  Segment2      Segment of the array holding the second sprite (Use VARSEG)
  -  Offset2       Offset of the array holding the second sprite (Use VARPTR)


Returns:

  0 if the sprites don't collide
 -1 if there is sprites collision


Description:

  This function checks if the two given sprites collide using a bounding box
  method. It returns -1 if there is collision 0 otherwise.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCollision FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSCollision% (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset%)


Parameters:

  -  Layer         The layer were to detect collision
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Returns:

  0 if no collision or the first non-zero color that collides with the sprite.


Description:

  This function returns the first non-zero color that collides with the sprite.
  You use this function like placing a sprite but this function actually
  doesn't draw it.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCollisionC FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSCollisionC% (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset%, BYVAL Col%)


Parameters:

  -  Layer         The layer were to detect collision
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data
  -  Col           The Col to test collision with

Returns:

  0 if no collision
  1 if collision with Col


Description:

  This function returns 1 if there is collision with the given color.
  You use this function like placing a sprite but this function actually
  doesn't draw it.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCpuId FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSCpuId$ ()


Returns:

  null              if CPU id not found
  "GenuineIntel"    if Intel processor
  "AuthenticAMD"    if AMD processor
  "CyrixInstead"    if Cyrix processor

Description:

  This cool function return the CPU vendor identification, if you get a null
  string then the CPU does not support CPUID instruction. If you get a string
  different to those mentioned above then you are running in a other brand
  processor.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCreateBMap FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSCreateBMap% ()


Returns:

  0 if successful
  1 if no memory
  2 if a blender map is already up


Description:

  This function allocates memory and prepares it for a blender map,
  you have to call this function before the other blender functions.
  If you don't know what's a blender map refer to the Blender Map section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDetectCPU FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSDetectCPU% ()


Returns:

   286  if CPU is 286 or lesser
   386  if CPU is 386
   486  if CPU is 486
   586  if CPU is Pentium
   686  if CPU is Pentium Pro, Pentium II or better (it may return 787).


Description:

  This function returns a number representing the current CPU, it's good to
  detect if there is a 386 or higher before using the other library functions
  because they use a lot of 32 bit instructions and if there is a lesser CPU
  it will to crash.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDetectEMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSDetectEMS% ()


Returns:

   0 if no EMS manager
   1 if there is EMS manager


Description:

  This function is used to detect if there are a EMS manager, always use
  this function before the other EMS function.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDetectMMX FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSDetectMMX% ()


Returns:

  0  if MMX not detected
  1  if MMX detected


Description:

  This function returns 1 if the current system supports MMX instructions, 0
  otherwise.
  MMX are special CPU instructions that were designed to speed up multimedia
  applications, including graphics. Now CosmoX supports this instructions to
  speed up some routines, if MMX is successfully detected, and you use CosmoX
  MMX routines, you will get a boost in your code. See Using MMX Routines
  section for more details.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDetectMouse FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSDetectMouse% ()


Returns:

   0 if no mouse driver
   1 if mouse successfully initialized


Description:

  This function is used to detect if there are a mouse driver and to
  initialize the CosmoX mouse driver. You must call this function before
  using mouse routines.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDetectWin FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSDetectWin% ()


Returns:

   0 if running under Windows 95 or higher (not NT)
   1 if not running under Windows (or couldn't detect it)


Description:

  This function is used to detect if the program is running under Windows
  95 or higher (not NT), you have to call this routine before calling any
  of the other Windows routines or they won't run.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDetectXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSDetectXMS% ()


Returns:

   0 if no XMS manager
   1 if there is XMS manager


Description:

  This function is used to detect if there are a XMS manager, always use
  this function before the other XMS function.
  You really have to use this function before the other XMS functions, or
  your program will crash!!


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDrive FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSDrive$ ()


Returns:

  The letter of the current drive.


Description:

  This functions returns a 1 character STRING holding the current drive
  letter.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSEMSHandles FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSEMSHandles% ()


Returns:

  The number of open EMS handles


Description:

  This functions returns the number of open EMS handles, it's useful to
  know how many handles are open so you don't get an error allocating memory.
  There is always an EMS handle open because it is in use by the operating
  system.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSEMSVersion FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSEMSVersion$ ()


Returns:

  A STRING holding the EMS version in the system.


Description:

  This function returns the version of the EMS implementation in the system.
  Don't forget to call CSDetectEMS before using any of the other EMS routines.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSElapsedTicks FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSElapsedTicks& (BYVAL WhichTimer%)


Parameters:

  - WhichTimer     Timer to get the ticks from


Returns:

  A LONG holding the number of times the given timer has been updated.


Description:

  This function returns the number of times the given timer has been updated.
  This is, if you set a timer to tick every second then this sub will return
  the number of seconds passed after setting the timer. This sub won't work
  if the CosmoX timer hasn't been installed with CSInstallTimer or the given
  timer hasn't been set.
  See the section "Using the timers".


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFindCol FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSFindCol% (BYVAL Red%, BYVAL Green%, BYVAL Blue%)


Parameters:

  -  Red           Red hue of the color to find
  -  Green         Green hue of the color to find
  -  Blue          Blue hue of the color to find


Returns:

 -1 if colors are too different
  0 - 255 index of the color that best matches the given hues


Description:

  This sub finds the color that best matches the given hues. Very useful when
  you are adjusting your palette. Note: this sub may return wrong numbers
  depending on the palette and the given hues, so use it with caution.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFindFile FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSFindFile$ (Mask$, Attribute%)


Parameters:

  -  Mask         Mask of file(s) to look for
  -  Attribute    Attribute of the file(s) to look for


Returns:

   A string with the file if found otherwise a null  string.


Description:

  You can use this function to scan the directory for any files, the first
  time you call it, you must pass a file mask that can have wildcards and
  it returns the first matching file, then you can continue calling it
  with a null string as mask and you'll get the next matching file,
  keep doing this until you get a null string and you'll get a full
  directory scan, with the Attribute parameter you can specify what kind
  of files you will look for, that way you can get directory, hidden
  and system files, too. There are some constant to make it easy for you,
  look the Library Constants section for more information about them.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFreeDiskSpc FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSFreeDiskSpc& (BYVAL DriveNumber%)


Parameters:

  -  DriveNumber       Number of the drive


Returns:

  The number of free bytes in the drive.


Description:

  This function it's useful if you want to store files on disk and you want to
  check if there is enough free space for them. The drive number is 0 for the
  default drive, 1 for the drive A, 2 for the drive B, 3 for C, and so on.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFreeEMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSFreeEMS% ()


Returns:

  The number of free kilobytes of EMS memory.


Description:

  This function returns the number of free KB of EMS memory so you can
  check if there is enough EMS memory for your purposes.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFreeEMSPages FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSFreeEMSPages% ()


Returns:

  The number of free pages of EMS memory.


Description:

  This function returns the number of free pages of EMS memory so you can
  check if there is enough EMS memory for your purposes.
  Remember, a EMS page is equal to 16 KB.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFreeXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSFreeXMS% ()


Returns:

  The number of free kilobytes of XMS memory.


Description:

  This function returns the number of free KB of XMS memory that can be
  allocated so you can check if there is enough EMS memory for your purposes.
  Don't forget to call CSDetectXMS before calling other XMS functions.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetBMap FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSGetBMap% (BYVAL ForeColor%, BYVAL BackColor%)


Parameters:

  -  ForeColor      The Foreground Color
  -  BackColor      The Background Color


Returns:

  An INTEGER value holding the color set for the specified combination in
  the blender map


Description:

  Returns the color set for the color set given by the specified combination
  of foreground and background color. If there is not a blender map up the
  function will return a -1. If you don't understand the blender map system
  refer to the Blender Map Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetCard FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSGetCard$ ()


Returns:

  A little STRING with the video card ID.


Description:

  Returns a string with the card ID. This string is dependent of the video
  card maker, so it can return a anything. This function uses a VESA BIOS
  call so if there is not a VESA BIOS then it will return a null string.
  This is useful in case you want to tell the user their card ID.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetEMSFrame FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSGetEMSFrame% ()


Returns:

  An INTEGER value holding the EMS frame address


Description:

  Returns the EMS page frame segment address so you can get access to the
  memory previously allocate by CSAllocateEMS.
  You need to pass this address to the graphics functions so you can draw on
  off screen layers. Don't forget that to access the memory you first have to
  map it. If you don't understand the EMS system refer to the EMS section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetTextSpacing FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSGetTextSpacing% ()


Returns:

  An INTEGER value holding current text spacing


Description:

  Returns the current text spacing that all the text routines except
  CSPrintSolid use.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSId FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSId$ ()


Returns:

  A STRING holding the library ID


Description:

  Returns a string with my nick and the library name in case you want to
  display them somewhere in your program.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitBlaster FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSInitBlaster% ()


Returns:

  0 - if couldn't initialize sound card
  1 - if card detected and successfully initialized


Description:

  This function tries to detect and to initialize the sound card. If it finds
  the sound card it resets it and updates internal variables. This function
  has to be called before any other sound routine.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSKey FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSKey% (BYVAL ScanCode%)


Parameters:

  -  ScanCode       Scan code of the key to check


Returns:

  0  if the key is  not pressed
  1  if the key is pressed


Description:

  This function checks if the key with the given scan code it's currently
  pressed, it returns 1 if the key it's pressed, 0 otherwise.
  This function only works if the custom keyboard handler it's on.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLen FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLen% (Text$)


Parameters:

  -  Text           Text string to get the length of


Returns:

  An INTEGER value holding the length of the string in pixels.


Description:

  This function returns the length of the given string in pixels units.
  The current character spacing is ignored to do this calculation, so if
  you have changed it, you won't get the exact result.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLoadBMP FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLoadBMP% (Layer%, X%, Y%, File$, Pal$)


Parameters:

  -  Layer          Layer to load the image on
  -  X              Starting X coordinate
  -  Y              Starting Y coordinate
  -  File           Filename of the BMP to load
  -  Pal            768 bytes string to store the image palette


Returns:

  0  if successful
  1  if couldn't open file
  2  if couldn't read file
  3  if not 256 color BitMap


Description:

  This function loads a 256 color BMP in the layer you specify in Layer
  the image palette is stored in Pal so you can set it whenever you want.
  No range checking nor clipping it's done in this function so be sure it's
  a 320x200 or less resolution image so it fits on screen.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLoadBMap FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLoadBMap% (FileName$)


Parameters:

  -  FileName           Filename of the BMap to load


Returns:

  0  if successful
  1  if couldn't open file
  2  if couldn't read file
  3  if not a blender map file


Description:

  This function loads a blender map previously saved with CSSaveBMap, you
  must call CSCreateBMap first to allocate memory for the blender map,
  otherwise this function will return doing nothing.
  To know more about the formats used by the library refer to Library
  Formats section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLoadFont FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLoadFont% (FileName$, FontBuffer$)


Parameters:

  -  FileName           Filename of the font to load
  -  FontBuffer         2048 characters string to store the font


Returns:

  0  if successful
  1  if couldn't open file
  2  if couldn't read file
  3  if not a font file


Description:

  This function loads a font file previously saved with the Font Editor.
  The FontBuffer must be a 2048 characters string. To set the loaded font as
  the active font, call CSSetFont after calling this function. To know more about
  the formats used by the library refer to Library Formats section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLoadPCX FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLoadPCX% (Layer%, X%, Y%, File$, Pal$)


Parameters:

  -  Layer          Layer to load the image on
  -  X              Starting X coordinate
  -  Y              Starting Y coordinate
  -  File           Filename of the PCX to load
  -  Pal            768 bytes string to store the image palette


Returns:

  0  if successful
  1  if couldn't open file
  2  if couldn't read file
  3  if not 256 color PCX


Description:

  This function loads a 256 color PCX in the layer you specify in Layer
  the image palette is stored in Pal so you can set it whenever you want.
  No range checking nor clipping it's done in this function so be sure it's
  a 320x200 or less resolution image so it fits on screen.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLoadPal FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLoadPal% (FileName$, Pal$)


Parameters:

  -  FileName         Filename of the palette to load
  -  Pal              A string of 768 characters to store the palette


Returns:

  0  if successful
  1  if couldn't open file
  2  if couldn't read file
  3  if not a palette file


Description:

  This function loads a palette file previously saved with CSSavePal.
  To know more about the formats used by the library refer to Library
  Formats section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLoadRawSound FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLoadRawSound% (SoundFile$, BufferSeg%, BufferOff&)


Parameters:

  - SoundFile         Filename of sound to load
  - BufferSeg         Segment of buffer to store sound
  - BufferOff         Offset of buffer to store sound


Returns:

  Size of the file if successfully loaded
  1 - if couldn't open file
  2 - if error reading file


Description:

  This function loads the given file and stores it in the given buffer (you
  need to make sure that buffer is big enough to hold the file). This
  function just loads the entire file into the given buffer, it is intended
  for sounds but it could be used for everything. It returns the file size
  if successful loading, error code otherwise.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLoadWavSound FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSLoadWavSound% (SoundFile$, BufferSeg%, BufferOff&)


Parameters:

  - SoundFile         Filename of sound to load
  - BufferSeg         Segment of buffer to store sound
  - BufferOff         Offset of buffer to store sound


Returns:

  Size of the file if successfully loaded
  1 - if couldn't open file
  2 - if error reading file
  3 - if not a wave file or bad format


Description:

  This function loads the given WAV file and stores it in the given buffer
  (you need to make sure that buffer is big enough to hold the file). If the
  file is bigger than 64 KB then it just loads the first 64 KB. It returns
  the sound data size if successfully loading, error code otherwise.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseClickOn FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSMouseClickOn% (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%)


Parameters:

  -  X1               The upper left X coordinate
  -  Y1               The upper left Y coordinate
  -  X2               The lower right X coordinate
  -  Y2               The lower right Y coordinate


Returns:

  0  if no click
  1  if click with left button
  2  if click with right button


Description:

  This function returns button info if the user click in the box determined
  by (X1, Y1) and (X2, Y2), returns 0 if no click were done, if 1 or 2 then
  click with left or right button respectively.
  Remember that it must be X1 < X2, and Y1 < Y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseLB FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSMouseLB% ()


Returns:

  0  if no press
  1  if the left button is pressed


Description:

  This function returns 1 if the left button is currently pressed 0 otherwise.
  You don't need to call another function to update the mouse status, it
  is updated automatically when the mouse moves or a button is pressed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseOver FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSMouseOver% (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%)


Parameters:

  -  X1               The upper left X coordinate
  -  Y1               The upper left Y coordinate
  -  X2               The lower right X coordinate
  -  Y2               The lower right Y coordinate


Returns:

  0  if the mouse isn't in the box
  1  if the mouse is in the box


Description:

  This function returns 1 if the mouse is located in the box determined
  by (X1, Y1) and (X2, Y2), returns 0 if the mouse is not in the box.
  Remember that it must be X1 < X2, and Y1 < Y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseRB FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSMouseRB% ()


Returns:

  0  if no press
  1  if the right button is pressed


Description:

  This function returns 1 if the right button is currently pressed 0 otherwise.
  You don't need to call another function to update the mouse status, it
  is updated automatically when the mouse moves or a button is pressed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseX FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSMouseX% ()


Returns:

  An INTEGER holding the current X position of the mouse.


Description:

  This function returns the horizontal position of the mouse. You don't need
  to call another function to update the mouse status, it is updated
  automatically when the mouse moves or a button is pressed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseY FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSMouseY% ()


Returns:

  An INTEGER holding the current Y position of the mouse.


Description:

  This function returns the vertical position of the mouse. You don't need to
  call another function to update the mouse status, it is updated automatically
  when the mouse moves or a button is pressed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPath FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSPath$ ()


Returns:

  A string holding the current path.


Description:

  This function returns a string with the current path, including drive letter.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPeek FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSPeek% (BYVAL Segment%, BYVAL Offset%)


Parameters:

  -  Segment          Segment to peek data from
  -  Offset           Offset to peek data from


Returns:

  An INTEGER holding the data stored in the word located in Segment:Offset.


Description:

  This function works the same as QB PEEK, but you specify the segment in the
  call, so it is more flexible.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPeek16 FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSPeek16% (BYVAL Segment%, BYVAL Offset%)


Parameters:

  -  Segment          Segment to peek data from
  -  Offset           Offset to peek data from


Returns:

  An INTEGER holding the data stored in the word located in Segment:Offset.


Description:

  This function works the same as QB PEEK, but you specify the segment in the
  call and it reads two bytes instead of one.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPeek32 FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSPeek32& (BYVAL Segment%, BYVAL Offset%)


Parameters:

  -  Segment          Segment to peek data from
  -  Offset           Offset to peek data from


Returns:

  A LONG holding the data stored in the double word located in Segment:Offset.


Description:

  This function works the same as QB PEEK, but you specify the segment in the
  call and it reads four bytes instead of one.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPoint FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSPoint% (BYVAL Layer%, BYVAL X%, BYVAL Y%)


Parameters:

  -  Layer            Layer to get the color from
  -  X                X coordinate
  -  Y                Y coordinate


Returns:

  An INTEGER holding the color in X and Y.


Description:

  This function works the same as QB POINT, but it can work on layers and it's
  faster.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPolyFacing FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSPolyFacing% (BYVAL Vec1Seg%, BYVAL Vec1Off%, BYVAL Vec2Seg%, BYVAL Vec2Off%, BYVAL Vec3Seg%, BYVAL Vec3Off%)


Parameters:

  - Vec1Seg         Segment of first vector
  - Vec1Off         Offset of first vector
  - Vec2Seg         Segment of second vector
  - Vec2Off         Offset of second vector
  - Vec3Seg         Segment of third vector
  - Vec3Off         Offset of third vector


Returns:

  An INTEGER holding the integer Z normal of the given vectors


Description:

  This function returns the integer Z normal of the given vectors. This is
  very useful when coding vector graphics, this is, by checking the sign of
  this value you can know if a polygon is facing to the viewer (and draw it
  if so). To make this thing work it needs the vectors to be defined in a
  clockwise direction (when is facing to the viewer). If your coordinate
  system is -Z going to the viewer and +Z is going into the screen the result
  of this function is negative if the polygon is visible and positive if it
  is not. This thing calculates the Z Normal with the cross product of two
  polygon edges (3 vertexes), and it does it with integer screen coordinates
  (perspective-projected points).


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSProcessor FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSProcessor$ ()


Returns:

  A STRING holding the processor present in the system


Description:

  This returns a little string that holds the processor present in the system.
  Just in case you want to print it somewhere.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSReadBit FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSReadBit% (BYVAL Value%, BYVAL Bit%)


Parameters:

  -  Value            Value to read the bit from
  -  Bit              Bit number


Returns:

  0  if the bit is off
  1  if the bit is on


Description:

  This function return the state of Bit on Value, very useful when working with
  bit fields. The bits are zero relative, so an INTEGER has 0-15 bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSReadKey FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSReadKey% ()


Returns:

  A INTEGER holding the scan code of the key pressed.


Description:

  This function waits for the user to press a key and returns it's scan code.
  This function only works if the custom keyboard handler it's on.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSResizeEMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSResizeEMS% (BYVAL Handle%, BYVAL Pages%)


Parameters:

  -  Handle           EMS Handle returned by CSAllocateEMS
  -  Pages            Number of pages to allocate


Returns:

  An INTEGER holding the actual number of pages allocated to Handle%. This
  function resizes previously allocated memory by a call to CSAllocateEMS to
  a new number of pages specified by Pages.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSResizeXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSResizeXMS% (BYVAL Handle%, BYVAL KB%)


Parameters:

  -  Handle           XMS Handle returned by CSAllocateXMS
  -  KB               Number of KB to allocate


Returns:

  0  if block of memory no reallocated
  1  if successful reallocation


Description:

  This function resizes previously allocated memory by a call to CSAllocateXMS
  to a new number of KiloBytes specified by KB.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSRotateL FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSRotateL% (BYVAL Value%, BYVAL Times%)


Parameters:

  -  Value            Value to rotate the bits on
  -  Times            Times to rotate the bits


Returns:

  An INTEGER holding the new value with the bits rotated.


Description:

  This function rotates the bits in Value to the left, it rotates them the
  times specified in Times, and returns the new value. If you rotate the bits
  past the end of the number they will appear on the right side of it. When you
  rotate a number to the left one time you multiply it by two, that way you can
  double a value faster than using a multiply.
  The bits are zero relative, so an INTEGER has 0-15 bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSRotateR FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSRotateR% (BYVAL Value%, BYVAL Times%)


Parameters:

  -  Value            Value to rotate the bits on
  -  Times            Times to rotate the bits


Returns:

  An INTEGER holding the new value with the bits rotated


Description:

  This function rotates the bits in Value to the right, it rotates them the
  times specified in Times, and returns the new value. If you rotate the bits
  past the end of the number they will appear on the left side of it. When you
  rotate a number to the right one time you divide it by two, that way you can
  halve a value faster than using a divide.
  The bits are zero relative, so an INTEGER has 0-15 bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSaveBMP FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSSaveBMP% (Layer%, X1%, Y1%, X2%, Y2%, File$, Pal$)


Parameters:

  -  Layer            Layer to get the image from
  -  X1               The upper left X coordinate
  -  Y1               The upper left Y coordinate
  -  X2               The lower right X coordinate
  -  Y2               The lower right Y coordinate
  -  File$            File name
  -  Pal$             Palette of the image


Returns:

  0  if successful
  1  if couldn't create file
  2  if couldn't write file


Description:

  This function takes the image between (X1, Y1) and (X2, Y2) and stores in
  File with the BMP format, you must pass the palette as a 768 bytes string,
  you can get the palette with CSGetPal.
  Remember that it must be X1 < X2, and Y1 < Y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSaveBMap FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSSaveBMap% (FileName$)


Parameters:

  -  FileName          File name


Returns:

  0  if successful
  1  if couldn't create file
  2  if couldn't write file
  3  if there isn't a blender map


Description:

  This function takes the current blender map stored in memory and saves to
  FileName$, this way you can create your blender map, store it in a file
  and load it in your program to skip the often slow setup of a blender map.
  Refer to Library Formats section to know more about the blender map format.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSavePal FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSSavePal% (FileName$, Pal$)


Parameters:

  -  FileName          File name
  -  Pal               A string of 768 characters holding the palette to store


Returns:

  0  if successful
  1  if couldn't create file
  2  if couldn't write file


Description:

  This function takes the palette stored in Pal and stores in FileName this
  way you can create your palette map, store it in a file and load it in your
  program to skip the often slow setup of a palette.
  Refer to Library Formats section to know more about the palette format.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetBit FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSSetBit% (BYVAL Value%, BYVAL Bit%)


Parameters:

  -  Value         Value to set the bit on
  -  Bit           Bit number (0-15)


Returns:

  The new value with the bit set.


Description:

  This function sets the bit specified in Bit to Value and returns it.
  The bits are zero relative, so an INTEGER has 0-15 bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSShiftL FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSShiftL% (BYVAL Value%, BYVAL Times%)


Parameters:

  -  Value            Value to shift bits on
  -  Times            Times to shift bits


Returns:

  An INTEGER holding the new value with the bits shifted.


Description:

  This function shifts the bits in Value to the left, it shifts them the
  times specified in Times, and returns the new value. If you shift the bits
  past the end of the number they will be lost. When you shift a number to the
  left one time you multiply it by two, that way you can double a value faster
  than using a multiply. The bits are zero relative, so an INTEGER has 0-15
  bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSShiftR FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSShiftR% (BYVAL Value%, BYVAL Times%)


Parameters:

  -  Value            Value to shift bits on
  -  Times            Times to shift bits


Returns:

  An INTEGER holding the new value with the bits shifted.


Description:

  This function shifts the bits in Value to the right, it shifts them the
  times specified in Times, and returns the new value. If you shift the bits
  past the end of the number they will be lost. When you shift a number to the
  right one time you divide it by two, that way you can halve value faster than
  using a divide. The bits are zero relative, so an INTEGER has 0-15 bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSize FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSSize% (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%)


Parameters:

  -  X1               The upper left X coordinate
  -  Y1               The upper left Y coordinate
  -  X2               The lower right X coordinate
  -  Y2               The lower right Y coordinate


Returns:

  The size in bytes of the sprite in the box (X1, Y1) and (X2, Y2).


Description:

  This function returns the size in bytes needed to DIMension the array to
  hold the sprite in (X1, Y1) and (X2, Y2). Remember that it must be X1 < X2,
  and Y1 < Y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSnapShot FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSSnapShot% (FileName$)


Parameters:

  -  FileName          The name of the file to store the BMP file


Returns:

  0  if successful
  1  if couldn't create file
  2  if couldn't write file


Description:

  This function takes whatever it's on screen and saves on a BMP.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSoundDone FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSSoundDone% ()


Returns:

  0 - if there is not a sound playing
  1 - if there is a sound playing


Description:

  This function returns the DMA chip status, it returns 1 if there is a
  sound still playing, 0 if no sound is being played.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTimerFlag FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSTimerFlag% (BYVAL WhichTimer%)


Parameters:

  - WhichTimer     Timer to get the flag from


Returns:

  0  if the given timer hasn't ticked
  1  if the given timer has ticked


Description:

  This function returns the flag of the given timer. If it returns 1 then the
  given timer has ticked, 0 otherwise. When you call this function and the
  given timer has ticked (and hence this function returns 1) the flag is
  set to 0 so you can wait for the next tick. This function won't work if the
  CosmoX timer hasn't been installed or the given timer hasn't been set.
  See the section "Using the timers".


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTimerTicks FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSTimerTicks& ()


Returns:

  A LONG number holding the number of timer ticks since midnight.


Description:

  This function returns the timer ticks since power on, it's very useful
  for speed testing. There are 18.2 of this ticks on a second.
  This sub isn't related to the CosmoX timer, so it will work if the timer
  hasn't been installed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSToggleBit FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSToggleBit% (BYVAL Value%, BYVAL Bit%)


Parameters:

  -  Value         Value to toggle the bit on
  -  Bit           Bit number (0-15)


Returns:

  The new value with the bit toggled.


Description:

  This function toggles the bit specified in Bit to Value and returns it.
  The bits are zero relative, so an INTEGER has 0-15 bits.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTotalDiskSpc FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSTotalDiskSpc& (BYVAL DriveNumber%)


Parameters:

  -  DriveNumber         The drive number


Returns:

  A LONG holding the total bytes of space in DriveNumber.


Description:

  This function returns the total bytes disk space in DriveNumber. The drive
  number is 0 for the default drive, 1 for the drive A, 2 for the drive B, 3
  for C, and so on.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTotalDrives FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSTotalDrives% ()


Returns:

  An INTEGER holding number of drives


Description:

  This function returns the number of logical drives in the system. A number
  of three, for example, means that A:, B: and C: are available.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTotalEMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSTotalEMS& ()


Returns:

  An LONG holding the total amount of KB of EMS.


Description:

  This function returns the total amount of free KiloBytes of EMS present in
  the system.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTotalEMSPages FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSTotalEMSPages% ()


Returns:

  An INTEGER holding the total amount of pages in EMS.


Description:

  This function returns the total amount of KiloBytes of EMS pages present in
  the system. A page is 16 KB long.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTotalXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSTotalXMS& ()


Returns:

  An LONG holding the total amount of KB of XMS.


Description:

  This function returns the total amount of free kilobytes of XMS present in
  the system.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSVectorDot FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSVectorDot! (Vec1Seg%, Vec1Off%, Vec2Seg%, Vec2Off%)


Parameters:

  - Vec1Seg%        Segment of first vector
  - Vec1Off%        Offset of first vector
  - Vec2Seg%        Segment of second vector
  - Vec2Off%        Offset of second vector


Returns:

  A SINGLE precision number holding the dot product of the given vectors.


Description:

  Given 2 vectors, this function returns the dot product of them. This kind of
  vector operation is used in 3D-Shading, if the vectors are unit vectors
  the dot product is equal to the cosine of the angle between the vectors.
  (If this kind of things doesn't make sense to you, look for a good 3D tutor)


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSVer FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSVer% ()


Returns:

  An INTEGER holding the current library version.


Description:

  This function returns the library version in an INTEGER value. The high
  byte represents the major version number and the low byte, the low version
  number.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinAppGetTitle FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinAppGetTitle$ ()


Returns:

  A STRING holding the title of the current application


Description:

  This function returns the title of the current application. This title is
  the one that appears when running under Windows at the top of the DOS
  window.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinChdir FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinChdir% (Dir$)


Parameters:

  - Dir         The directory to change to.


Returns:

  0 if successful, if other number is returned then a error ocurred.


Description:

  This function changes the current directory to the given one, but this
  routine accepts long filenames and works only under Windows.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinDelFile FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinDelFile% (File$)


Parameters:

  - File        The file to delete


Returns:

  0 if successful, if other number is returned then a error ocurred.


Description:

  This function deletes the given file, this routine accepts long filenames
  and works only under Windows.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinFindFile FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinFindFile$ (File$, Attributes%)


Parameters:

  - File        The file mask to search for (* and ? allowed).
  - Attributes  The searching attributes


Returns:

  A STRING holding the first file matching the file mask, a null string
  if none matched.


Description:

  This function searches the current directory (or if the file mask contains
  a directory specified then it will search there) for the first file matching
  the given file mask, * and ? are allowed wildcards.
  If you want to search for the next matching file then you should call
  CSWinFindNext. Remember to call CSWinFindClose after a directory scan.
  See the CosmoX Constants Section for a reference on the attributes that
  you can give to this routine.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinFindFile FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinFindNext$ ()


Returns:

  A STRING holding the next file matching the file mask given on the last call
  to CSWinFindFile, a null string if none matched.


Description:

  This function searches the current directory for the next file matching
  the given file mask on the last call to CSWinFindFile. If a null string
  is returned then all the directory was scanned. Remember to call
  CSWinFindClose after a directory scan.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinGetClipBDataSize FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinGetClipBDataSize& ()


Returns:

  A LONG that holds the number of bytes that the Windows clipboard has
  stored (always a multiple of 32).


Description:

  This function returns the size of the data that the Windows clipboard
  is holding at the time of the call. This number is always a multiple of
  32, because Windows rounds it for performance reasons.
  You should call CSWinOpenClipB to open the clipboard before calling any
  other routine that interacts with it, also, you should close the clipboard
  before exiting your programs, using CSWinCloseClipB.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinGetClipBDataType FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinGetClipBDataType% ()


Returns:

  An INTEGER that holds the type of data that the Windows clipboard has
  stored.


Description:

  This function returns the type of the data that the Windows clipboard
  is holding at the time of the call. To see a list of possible formats
  of data that you can access see the CosmoX Constants Section.
  You should call CSWinOpenClipB to open the clipboard before calling any
  other routine that interacts with it, also, you should close the clipboard
  before exiting your programs, using CSWinCloseClipB.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinGetVMID FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinGetVMID% ()


Returns:

  An INTEGER that holds the current Virtual Machine ID.


Description:

  Under Windows, every DOS program runs on something called Virtual Machine,
  that emulates old DOS. Every  Virtual Machine has an ID number that helps
  Windows reference them internally, this functions returns that ID. This
  routine isn't that useful, but it's kinda nice to know your VM ID sometimes.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinMakeDir FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinMakeDir% (Dir$)


Parameters:

  - Dir         The directory to create.


Returns:

  0 if successful, if other number is returned then a error ocurred.


Description:

  This function creates the given directory, this routine accepts long
  filenames and works only under Windows.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinOpenClipB FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinOpenClipB% ()


Returns:

  0 if successful, if other number is returned then a error ocurred.


Description:

  This function opens the Windows clipboard so you can start to communicate
  with it, you should always call this routine before using any other
  clipboard routine, also, you should close the clipboard before exiting your
  programs, using CSWinCloseClipB.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinPath FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinPath$ ()


Returns:

  A STRING holding the current path.


Description:

  This function is the same as CSPath, but this one returns long filenames
  too, and runs only under Windows.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinRemoveDir FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinRemoveDir% (Dir$)


Parameters:

  - Dir         The directory to remove.


Returns:

  0 if successful, if other number is returned then a error ocurred.


Description:

  This function removes the given directory, this routine accepts long
  filenames and works only under Windows.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinVMGetTitle FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSWinVMGetTitle$ ()


Returns:

  A STRING holding the title of the current Virtual Machine.


Description:

  This function returns the title of the current application Virtual Machine.
  This title is the one that appears when running under Windows at the top of
  the DOS window (it usually says "MS-DOS", "DOS" or "COMMAND".
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSXAllocateXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSXAllocateXMS% (BYVAL KB&)


Parameters:

  - KB          Number of KB to allocate from XMS


Returns:

  A XMS handle that you need to continue operating this memory and to free it.


Description:

  This function is the same as CSAllocateXMS, but it uses Super Extended
  Memory calls, so you can allocate  all the free memory on the system
  (normal routines has a 64 MB limit), you free memory allocated with this
  routine the same as normal XMS (with CSDeallocateXMS).


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSXFreeXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSXFreeXMS& ()


Returns:

  An LONG holding the free KBs of XMS.


Description:

  This function returns the amount of free kilobytes of XMS that you can
  allocate present in the system, but this routine uses the Super Extended
  Memory calls, so it returns all the free memory (normal routines has a
  64 MB limit), if you don't need more than 64 MB then use the normal routines.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSXMSHandles FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSXMSHandles% ()


Returns:

  The number of free XMS handles


Description:

  This functions returns the number of free XMS handles, it's useful to know
  how many handles are free so you don't get an error allocating memory.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSXMSVersion FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSXMSVersion$ ()


Returns:

  A STRING holding the XMS version in the system.


Description:

  This function returns the version of the XMS implementation in the system.
  Don't forget to call CSDetectXMS before using any of the other XMS routines
  or the system may crash.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSXNormal FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSXNormal! (Vec1Seg%, Vec1Off%, Vec2Seg%, Vec2Off%, Vec3Seg%, Vec3Off%)


Parameters:

  - Vec1Seg%        Segment of first vector
  - Vec1Off%        Offset of first vector
  - Vec2Seg%        Segment of second vector
  - Vec2Off%        Offset of second vector
  - Vec3Seg%        Segment of third vector
  - Vec3Off%        Offset of third vector


Returns:

  A SINGLE precision number holding the X part of the polygon normal


Description:

  Given 3 vectors (in clockwise order), this function returns the X part of
  the normal vector of the polygon (a normal vector is a vector perpendicular
  to the given polygon), this kind of thing is useful when doing 3D-Shading,
  use this in conjunction with CSYNormal and CSZNormal to get the complete
  vector.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSXResizeXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSXResizeXMS% (BYVAL Handle%, BYVAL KB%)


Parameters:

  -  Handle           XMS Handle returned by CSXAllocateXMS
  -  KB               Number of KB to allocate


Returns:

  0  if block of memory no reallocated
  1  if successful reallocation


Description:

  This function resizes previously allocated memory by a call to CSXAllocateXMS
  to a new number of KiloBytes specified by KB, this function is the same as
  CSResizeXMS only that it works with Super Extended Memory, this is a way to
  allocate all the memory the system has (the normal routines have a limit of
  64 MB), it is recommended that you use the normal routines if you don't
  need all that memory (64 MB is OK, I guess =) ).


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSXTotalXMS FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSXTotalXMS& ()


Returns:

  An LONG holding the total of free KB of XMS.


Description:

  This function returns the total amount of free kilobytes of XMS present in
  the system, but this routine uses the Super Extended Memory calls, so it
  returns all the free memory (normal routines has a 64 MB limit), if you
  don't need more than 64 MB then use the normal routines.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSYNormal FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSYNormal! (Vec1Seg%, Vec1Off%, Vec2Seg%, Vec2Off%, Vec3Seg%, Vec3Off%)


Parameters:

  - Vec1Seg%        Segment of first vector
  - Vec1Off%        Offset of first vector
  - Vec2Seg%        Segment of second vector
  - Vec2Off%        Offset of second vector
  - Vec3Seg%        Segment of third vector
  - Vec3Off%        Offset of third vector


Returns:

  A SINGLE precision number holding the Y part of the polygon normal


Description:

  Given 3 vectors (in clockwise order), this function returns the Y part of
  the normal vector of the polygon (a normal vector is a vector perpendicular
  to the given polygon), this kind of thing is useful when doing 3D-Shading,
  use this in conjunction with CSXNormal and CSZNormal to get the complete
  vector.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSZNormal FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE FUNCTION CSZNormal! (Vec1Seg%, Vec1Off%, Vec2Seg%, Vec2Off%, Vec3Seg%, Vec3Off%)


Parameters:

  - Vec1Seg%        Segment of first vector
  - Vec1Off%        Offset of first vector
  - Vec2Seg%        Segment of second vector
  - Vec2Off%        Offset of second vector
  - Vec3Seg%        Segment of third vector
  - Vec3Off%        Offset of third vector


Returns:

  A SINGLE precision number holding the Z part of the polygon normal


Description:

  Given 3 vectors (in clockwise order), this function returns the Z part of
  the normal vector of the polygon (a normal vector is a vector perpendicular
  to the given polygon), this kind of thing is useful when doing 3D-Shading,
  use this in conjunction with CSXNormal and CSYNormal to get the complete
  vector.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSAntiAliase SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSAntiAliase (BYVAL Layer%)


Parameters:

  -  Layer         The layer to smooth


Description:

  This sub performs bilinear filtering in the given layer, this sub can make
  very cool effects like smoothing a layer, blurring, etc., it needs a gradient
  palette to work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSBlackPal SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSBlackPal (BYVAL FirstCol%, BYVAL LastCol%, BYVAL Red%, BYVAL Green%, BYVAL Blue%)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index
  -  Red           The red hue
  -  Green         The green hue
  -  Blue          The blue hue


Description:

  This sub sets the colors between the first and last color indexes to the
  specified red, green and blue hues. The last color index must be greater
  than the first and be in the range 0-255.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSBox SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSBox (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  Col           The drawing color


Description:

  This sub draws an empty box in the given layer with the upper left corner
  (X1, Y1) and lower right corner (X2, Y2) with the specified color.
  This sub it's not clipped so be sure it's on the screen or your program may
  crash. It doesn't need that x1 < x2 and y1 < y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSBoxF SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSBoxF (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  Col           The drawing color


Description:

  This sub draws a filled box in the given layer with the upper left corner
  (X1, Y1) and lower right corner (X2, Y2) with the specified color.
  This sub it's not clipped so be sure it's on the screen or your program may
  crash. It doesn't need that x1 < x2 and y1 < y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSBoxFB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSBoxFB (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  Col           The drawing color


Description:

  This is the same as the last one, it just blends the color with the
  background using the blender map. If there is no blender map activated then
  this routines does nothing. This routine is affected by the clipping box.
  It doesn't need that x1 < x2 and y1 < y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSButton SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSButton (Layer%, X1%, Y1%, X2%, Y2%, ButCol%, TextCol%, Shadow%, Light%, Text$)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  ButCol        The button color
  -  TextCol       The text color
  -  Shadow        The button shadow
  -  Light         The button light
  -  Text          The button text


Description:

  This sub draws a button in the given layer, with the upper corner in
  (X1, Y1) and lower corner in (X2, Y2), with the specified color in
  ButCol, the text will be centered in the button and with the given TextCol,
  the Shadow and Light parameters are colors that give the button a 3D shape.
  Remember that it must be X1 < X2, and Y1 < Y2, and the text will not be
  clipped in the button, so be sure it fits on it.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCircle SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSCircle (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Rad%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X             The center X coordinate
  -  Y             The center Y coordinate
  -  Rad           The radius of the circle
  -  Col           The drawing color


Description:

  This sub draws an empty circle in the given layer and with the given color,
  with center on X, Y and with a Rad radius. This sub is affected by the
  clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCircleF SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSCircleF (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Rad%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X             The center X coordinate
  -  Y             The center Y coordinate
  -  Rad           The radius of the circle
  -  Col           The drawing color


Description:

  This sub draws a filled circle in the given layer and with the given color,
  with center on X, Y and with a Rad radius. This sub is affected by the
  clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSClear SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSClear (BYVAL Layer%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  Col           The drawing color


Description:

  This sub clears the given layer to the given color, works almost like CLS
  but it can work on layers, it can set it to a custom color and it's a lot
  faster.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSClearMMX SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSClearMMX (BYVAL Layer%, BYVAL Col%)


Parameters:

  -  Layer          Layer to clear
  -  Col            Color to clear the layer with


Description:

  This routine is the same as CSClear, it clears the given layer with a given
  color, but it uses MMX instructions instead of normal ones, so it will run
  faster. You have to call CSDetectMMX before using this routine.
  Don't worry, if the CPU doesn't support MMX instructions and you call this
  routine, CosmoX will not use MMX instructions, so the CPU won't crash, but
  for this to work, you have to call CSDetectMMX before any MMX routine.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSClose SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSClose ()


Description:

  This function removes the custom keyboard handler, the timer handler,
  destroys the blender map and sets text mode.
  This is function is very handy when you are using all this stuff and don't
  want to close them all by yourself. You better put this at the end of your
  program.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSContinueSound SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSContinueSound ()


Description:

  This sub continues a sound that was paused with CSPauseSound. If you call
  this sub without a paused sound the result is undefined.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCopyBlock SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSCopyBlock (BYVAL Source%, BYVAL Destiny%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%)


Parameters:

  -  Source        Source layer
  -  Destiny       Destiny layer
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate


Description:

  This routine copies the content of the source layer to the destiny layer,
  but it copies only the given rectangle, not the entire layer, this is very
  useful when doing animation, because you can restore the background only
  copying the bounding rectangle of a given sprite, not the entire layer,
  this will make for faster animation (I think this thing is called dirty
  rectangle animation).
  Remember that it must be X1 < X2, and Y1 < Y2, or the system may crash.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSCopyMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSCopyMatrix (BYVAL SMatrixS%, BYVAL SMatrixO%, BYVAL DMatrixS%, BYVAL DMatrixO%)


Parameters:

  - SMatrixS          Segment of the source 4x4 matrix
  - SMatrixO          Offset of the source 4x4 matrix
  - DMatrixS          Segment of the destiny 4x4 matrix
  - DMatrixO          Offset of the destiny 4x4 matrix


Description:

  This routine copies the source matrix to the destiny matrix.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDeallocateEMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSDeallocateEMS (BYVAL Handle%)


Parameters:

  -  Handle         The EMS handle to free


Description:

  This sub will free the EMS memory allocated by CSAllocateEMS in Handle.
  Always remember to call this function for all the EMS handles you have
  allocated in your program before exiting or the memory will be lost and
  won't be accessible until the machine is rebooted.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDeallocateXMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSDeallocateXMS (BYVAL Handle%)


Parameters:

  -  Handle         The XMS handle to free


Description:

  This sub will free the XMS memory allocated by CSAllocateXMS in Handle.
  Always remember to call this function for all the XMS handles you have
  allocated in your program before exiting or the memory will be lost and
  won't be accessible until the machine is rebooted.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDelay SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSDelay (BYVAL Increments%)


Parameters:

  -  Increments      The number of times to wait


Description:

  This sub waits the given times for the monitor vertical retrace, is
  very useful to delay for something.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSDestroyBMap SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSDestroyBMap ()


Description:

  This sub frees the blender map memory thus destroying it. It returns doing
  nothing if there isn't a blender map.
  Once you destroy a blender map it cannot be retrieved and the blending
  functions will not work unless another blender map it's created.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSEllipse SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSEllipse (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL RadX%, BYVAL RadY%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X             The center X coordinate
  -  Y             The center Y coordinate
  -  RadX          The X radius of the ellipse
  -  RadY          The Y radius of the ellipse
  -  Col           The drawing color


Description:

  This sub draws an empty ellipse in the given layer with center on X, Y,
  with a RadX horizontal radius, and a RadY vertical radius, and with the
  given color. This sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSEllipseF SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSEllipseF (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL RadX%, BYVAL RadY%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X             The center X coordinate
  -  Y             The center Y coordinate
  -  RadX          The X radius of the ellipse
  -  RadY          The Y radius of the ellipse
  -  Col           The drawing color


Description:

  This sub draws a filled ellipse in the given layer with center on X, Y,
  with a RadX horizontal radius, and a RadY vertical radius, and with the
  given color. This sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFadeIn SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSFadeIn (FirstCol%, LastCol%, Pal$)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index
  -  Pal           A string of 768 characters holding the palette to fade into


Description:

  This sub fades the color indexes between FirstCol and LastCol to the ones
  in the given palette, the palette can be obtained with CSGetPal, CSLoadBMP,
  CSLoadPCX, or CSLoadPal. The palette can also be setup manually, refer to
  the Library Format Section to know how the palette it's stored.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFadeInStep SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSFadeInStep (FirstCol%, LastCol%, Pal$)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index
  -  Pal           A string of 768 characters holding the palette to fade into


Description:

  This sub it's very similar to CSFadeIn except it fades the palette in just
  one step, so to fade the entire palette you need to call this function 64
  times, it's very useful to fade while animating.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFadeTo SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSFadeTo (BYVAL FirstCol%, BYVAL LastCol%, BYVAL Red%, BYVAL Green%, BYVAL Blue%)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index
  -  Red           The red hue
  -  Green         The green hue
  -  Blue          The blue hue


Description:

  This sub fades the color indexes between FirstCol and LastCol to the given
  red, green and blue hues, it's very cool because it can fade to any color.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFadeToStep SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSFadeToStep (BYVAL FirstCol%, BYVAL LastCol%, BYVAL Red%, BYVAL Green%, BYVAL Blue%)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index
  -  Red           The red hue
  -  Green         The green hue
  -  Blue          The blue hue


Description:

  This sub it's very similar to CSFadeTo except it fades the palette in just
  one step, so to fade the entire palette you need to call this function 64
  times, it's very useful to fade while animating.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFfix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSFfix ()


Description:

  This sub fixes a bug on QB code that makes QB's floating point operations
  slower than they should be. When you use this routine you can get a 300%
  speed up on floating point operations.
  Don't forget to call CSRemoveFfix or CSClose to remove this fixup at the
  end of your program or your may crash your machine.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSFire SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSFire (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL FWidth%, BYVAL MaxColorIndex%, BYVAL MaxScanLine%)


Parameters:

  -  Layer         The layer to draw the fire on
  -  X             The upper bottom X coordinate
  -  Y             The upper left Y coordinate
  -  FWidth        The width of the fire
  -  MaxColorIndex Maximun color
  -  MaxScanLine   The number of scanlines to go up


Description:

  This sub gives you a very nice fire effect when used with the right
  palette, it starts on the given X and Y and grows to the right the
  number given on FWidth and grows up to the number Y - MaxScanLine, this
  is, it grows up the number of scanlines you give them. It starts its
  color averaging with the color given on MaxColorIndex and grows downwards
  from it, depending on your palette you can get very nice fires.
  Have in mind that you can't clear the layer where you are drawing your
  fire, because it needs the results from the last frame to produce a new one.
  This routine doesn't any kind of clipping, so be careful.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGet SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSGet (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL Segment%, BYVAL Offset%)


Parameters:

  -  Layer         The layer to get the sprite from
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  Segment       Segment of the array to store the sprite (use VARSEG)
  -  Offset        Offset of the array to store the sprite (use VARPTR)


Description:

  This sub gets the sprite from the given layer, in the (X1, Y1)-(X2, Y2)
  box and stores in the given array address. The array must be DIMensioned
  with the formula ((Width * Height) + 4) / 2. To make things easier you
  can use CSSize to get the correct value for the sprite. Sprites stored
  with this sub are compatibles with the ones stored by QB.
  This function it's not clipped and the coordinates must be X1 < X2 and
  Y1 < Y2. Different sprites can be stored in the same array if you use
  different indexes, just make sure that your array is big enough to hold
  the sprites. Also, it is optimized if your sprite width is multiple of
  2 or 4.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetClipBox SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSGetClipBox (X1%, Y1%, X2%, Y2%)


Parameters:

  -  X1            INTEGER variable to store the upper left X coordinate
  -  Y1            INTEGER variable to store the upper left Y coordinate
  -  X2            INTEGER variable to store the lower right X coordinate
  -  Y2            INTEGER variable to store the lower right Y coordinate


Description:

  This sub stores the current clip box coordinates in the given variables.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetCol SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSGetCol (BYVAL Col%, Red%, Green%, Blue%)


Parameters:

  -  Col           Color index to get the hues from
  -  Red           INTEGER variable to store the red hue
  -  Green         INTEGER variable to store the green hue
  -  Blue          INTEGER variable to store the blue hue


Description:

  This sub gets the red, green and blue hues of the given color and stores
  in the given variables.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetFont SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSGetFont (Font$)


Parameters:

  -  Font           2048 characters string to store the font


Description:

  This sub gets the current font and stores in Font, Font must be a
  2048 characters string, this function is useful if you want to use
  different fonts in your programs. To know how the font is stored then
  refer to the Library Formats Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGetPal SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSGetPal (Pal$)


Parameters:

  -  Pal            768 characters string to store the palette


Description:

  This sub gets the current palette and stores in Pal, Pal must be a 768
  characters string. To know how the palette is stored then refer to the
  Library Formats Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGradientPal SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSGradientPal (Col1%, Col2%)


Parameters:

  -  Col1          First color index
  -  Col2          Second color index


Description:

  This sub creates a gradient palette by interpolating between the hue values
  in the given color indexes, it can create very cool palettes in the blink of
  an eye, so try it out.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSGrayPal SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSGrayPal (BYVAL FirstCol%, BYVAL LastCol%)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index


Description:

  This sub sets the colors between the first and last color indexes to
  gray scales.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSIdentityMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

    DECLARE SUB CSIdentityMatrix (BYVAL MatrixSeg%, BYVAL MatrixOff%)


Parameters:

  - MatrixSeg          Segment of the 4x4 matrix
  - MatrixOff          Offset of the 4x4 matrix


Description:

  This routine sets the matrix in the specified memory location to identity.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitRotXMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInitRotXMatrix (BYVAL MatrixSeg%, BYVAL MatrixOff%, BYVAL Cosine!, BYVAL Sine!)


Parameters:

  - MatrixSeg          Segment of the 4x4 matrix
  - MatrixOff          Offset of the 4x4 matrix
  - Cosine             Cosine of rotation angle
  - Sine               Sine of rotation angle


Description:

  This routine sets the matrix in the specified memory location to the
  X-axis rotation matrix. Cosine and Sine are single precision numbers.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitRotYMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInitRotYMatrix (BYVAL MatrixSeg%, BYVAL MatrixOff%, BYVAL Cosine!, BYVAL Sine!)


Parameters:

  - MatrixSeg          Segment of the 4x4 matrix
  - MatrixOff          Offset of the 4x4 matrix
  - Cosine             Cosine of rotation angle
  - Sine               Sine of rotation angle


Description:

  This routine sets the matrix in the specified memory location to the
  Y-axis rotation matrix. Cosine and Sine are single precision numbers.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitRotZMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInitRotZMatrix (BYVAL MatrixSeg%, BYVAL MatrixOff%, BYVAL Cosine!, BYVAL Sine!)


Parameters:

  - MatrixSeg          Segment of the 4x4 matrix
  - MatrixOff          Offset of the 4x4 matrix
  - Cosine             Cosine of rotation angle
  - Sine               Sine of rotation angle


Description:

  This routine sets the matrix in the specified memory location to the
  Z-axis rotation matrix. Cosine and Sine are single precision numbers.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitScaleMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInitScaleMatrix (BYVAL MatrixSeg%, BYVAL MatrixOff%, BYVAL ScaleX!, BYVAL ScaleY!, BYVAL ScaleZ!)


Parameters:

  - MatrixSeg          Segment of the 4x4 matrix
  - MatrixOff          Offset of the 4x4 matrix
  - ScaleX             Scaling of the X element
  - ScaleY             Scaling of the Y element
  - ScaleZ             Scaling of the Z element


Description:

  This routine sets the matrix in the specified memory location to the scaling
  matrix. All the scaling values are single precision floating-point numbers.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitText SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInitText ()


Description:

  This sub sets the plain 25x80 text video mode (e.g 03h). If you use this
  function instead of SCREEN 0 you can get smaller executables when you
  compile your program.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitTransMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInitTransMatrix (BYVAL MatrixSeg%, BYVAL MatrixOff%, BYVAL TransX!, BYVAL TransY!, BYVAL TransZ!)


Parameters:

  - MatrixSeg          Segment of the 4x4 matrix
  - MatrixOff          Offset of the 4x4 matrix
  - TransX             Translating value of the X element
  - TransY             Translating value of the Y element
  - TransZ             Translating value of the Z element


Description:

  This routine sets the matrix in the specified memory location to the
  translate matrix. All the translating values are single precision floating-
  point numbers.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInitVGA SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInitVGA ()


Description:

  This sub sets the 320x200x256 graphics video mode (e.g 13h). If you use
  this sub instead of SCREEN 13 you can get smaller executables when you
  compile your program.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInstallKeyBoard SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInstallKeyBoard ()


Description:

  This sub installs the custom keyboard handler, this handler unlike QB INKEY$
  can read several keys at the same type which is very useful for games and
  graphics applications, this handler uses an internal buffer to store the
  keys so it won't overflow the BIOS default. When you turn on the handler
  don't forget to turn it off,if you fail to do that you will be trapped in
  your program and you will have to reboot.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSInstallTimer SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSInstallTimer ()


Description:

  This sub install the CosmoX timer, it has to be called before any other
  timer routine or they won't work.
  You can have up to 16 timers, all running at different speeds, so you can
  time your program speed (frame rate), a game timer, the number of seconds
  or minutes your program has running, etc.
  See the section "Using the timers".


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLine SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSLine (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL Col%)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The first point X coordinate
  -  Y1            The first point Y coordinate
  -  X2            The last point X coordinate
  -  Y2            The last point Y coordinate
  -  Col           Color of the line


Description:

  This sub draws a line from point (X1, Y1) to point (X2, Y2) in the given
  layer, with the given color. This sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSLockKeys SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSLockKeys (BYVAL LKey%, BYVAL State%)


Parameters:

  -  LKey          Lock key to change
  -  State         The new state of the lock key


Description:

  This sub sets the state of the given lock key, if you pass 1 in State%
  then it will turn on the lock key, if you pass 0 it will turn it off. The
  key codes are as follow : NUMLOCK = 0, CAPSLOCK = 1, SCROLLLOCK =  2. There
  are some constant to make it easy for you, refer to the Library Constants
  Section to know about them.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMakePhongPal SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMakePhongPal (Ra!, Rd!, Rs!, Ga!, Gd!, Gs!, Ba!, Bd!, Bs!, N%, Col1%, Col2%)


Parameters:

  -  Ra             Red ambient light factor
  -  Rd             Red diffuse light factor
  -  Rs             Red specular light factor
  -  Ga             Green ambient light factor
  -  Gd             Green diffuse light factor
  -  Gs             Green specular light factor
  -  Ba             Blue ambient light factor
  -  Bd             Blue diffuse light factor
  -  Bs             Blue specular light factor
  -  N              Specular reflection parameter
  -  Col1           First color of the range
  -  Col2           Second color of the range


Description:

  This sub calculates a palette between the given colors using the phong
  illumination model, you can use it with gouraud-shading to create fake
  phong-shaded objects, this is pretty cool if you take in account that
  gouraud-shading is by far much faster than real phong-shading.
  Mess with this function a lot, you can create very cool palettes with it,
  or you can try seeing DemoX (CosmoX demonstration), it has a customizable
  phong-shaded cube.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMapEMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMapEMS (BYVAL Handle%, BYVAL PhyPage%, BYVAL LogPage%)


Parameters:

  -  Handle        EMS Handle
  -  PhyPage       Physical page index (0-3)
  -  LogPage       Logical page in handle


Description:

  This sub maps the given logical page of the given handle in the specified
  physical page, the physical page index must be in the range 0 to 3, the
  given value will be ANDed with 3 to avoid problems. The logical page must
  be in the range 0 to the number of allocated page minus 1, so they are zero
  relative. This function is provided so you can store custom data in EMS, to
  map layers use the CSMapEMSLayer sub, it is more versatile. Refer to the EMS
  Section for more detailed info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMapEMSLayer SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMapEMSLayer (BYVAL Handle%, BYVAL LogPage%)


Parameters:

  -  Handle        EMS Handle
  -  LogPage       Logical page in handle


Description:

  This sub maps 4 logical pages allocated in Handle in the EMS frame,
  starting from the given logical page, so your Handle must have at least
  4 logical pages allocated. This function is more versatile than CSMapEMS
  and it is provided so you can map an entire layer at once, when a layer is
  mapped it's ready to use, you must get the frame address with CSGetEMSFrame.
  Refer to the EMS Section for more detailed info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMatrixMulMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMatrixMulMatrix (BYVAL MatrixSeg%, BYVAL MatrixOff%, BYVAL TMatrixSeg%, BYVAL TMatrixOff%)


Parameters:

  - MatrixSeg          Segment of the source 4x4 matrix
  - MatrixOff          Offset of the source 4x4 matrix
  - TMatrixSeg         Segment of the 4x4 transformation matrix
  - TMatrixOff         Offset of the 4x4 transformation matrix


Description:

  This routine transforms the source matrix by the transformation matrix, this
  is, it multiplies them together. The result is placed in the source matrix.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMemCopy SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMemCopy (BYVAL SSegment%, BYVAL SOffset%, BYVAL DSegment%, BYVAL DOffset%, BYVAL Bytes%)


Parameters:

  -  SSegment      Source segment
  -  SOffset       Source offset
  -  DSegment      Destiny segment
  -  DOffset       Destiny offset
  -  Bytes         Number of bytes to copy


Description:

  This sub copies the given number of bytes from the specified source segment
  and source offset to the destiny segment and offset, very useful to copy
  arrays. This sub is optimized if the number of bytes is multiple of 2 or 4.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMemCopyMMX SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMemCopyMMX (BYVAL SSegment%, BYVAL SOffset&, BYVAL DSegment%, BYVAL DOffset&, BYVAL Bytes&)


Parameters:

  -  SSegment      Source segment
  -  SOffset       Source offset
  -  DSegment      Destiny segment
  -  DOffset       Destiny offset
  -  Bytes         Number of bytes to copy


Description:

  This sub is the same as the last one, the only difference is that this
  will use MMX instructions to make it pretty fast (if available, if not,
  it will use normal instructions).
  Optimized for moves that are divisible by 8.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMemSwap SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMemSwap (BYVAL Segment1%, BYVAL Offset1%, BYVAL Segment2%, BYVAL Offset2%, BYVAL Bytes%)


Parameters:

  -  Segment1      First segment
  -  Offset1       First offset
  -  Segment2      Second segment
  -  Offset2       Second offset
  -  Bytes         Number of bytes to swap


Description:

  This sub swaps the given number of bytes from the specified segments and
  offsets, this sub is useful to swap arrays. This sub is optimized if the
  number of bytes is multiple of 2 or 4.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMemSwapMMX SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMemSwapMMX (BYVAL SSegment%, BYVAL SOffset&, BYVAL DSegment%, BYVAL DOffset&, BYVAL Bytes&)


Parameters:

  -  SSegment      Source segment
  -  SOffset       Source offset
  -  DSegment      Destiny segment
  -  DOffset       Destiny offset
  -  Bytes         Number of bytes to copy


Description:

  This sub is the same as the last one, the only difference is that this
  will use MMX instructions to make it pretty fast (if available, if not,
  it will use normal instructions).
  Optimized for moves that are divisible by 8.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseOff SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMouseOff ()


Description:

  This sub hides the mouse cursor if it is visible. Although the cursor isn't
  visible the mouse remains active.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMouseOn SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMouseOn ()


Description:

  This sub shows the mouse cursor if it is not visible.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMoveEMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMoveEMS (BYVAL SHandle%, BYVAL SLogPage%, BYVAL SPageOffset%, BYVAL DHandle%, BYVAL DLogPage%, BYVAL DPageOffset%, BYVAL Length&)


Parameters:

  -  SHandle        Source EMS Handle
  -  SLogPage       Source logical page
  -  SPageOffset    Source logical page offset
  -  DHandle        Destiny EMS Handle
  -  DLogPage       Destiny logical page
  -  DPageOffset    Destiny logical page offset
  -  Length         Length of EMS to move (in bytes)


Description:

  This sub copies the given bytes of EMS memory from source handle, source
  logical page and source logical page offset to destiny handle, destiny
  logical page and destiny logical page offset, the source and destiny offsets
  must be in the range 0 to 16383 because a logical page is 16K in size. The
  source handle can be the same that destiny handle and the memory can overlap.
  Refer to the EMS Section to get more info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMoveFromEMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMoveFromEMS (BYVAL Segment%, BYVAL Offset%, BYVAL Handle%, BYVAL LogPage%, BYVAL PageOffset%, BYVAL Length&)


Parameters:

  -  Segment        Conventional memory segment
  -  Offset         Conventional memory offset
  -  Handle         Source EMS Handle
  -  LogPage        Source logical page
  -  PageOffset     Source logical page offset
  -  Length         Length of memory to move (in bytes)


Description:

  This sub copies the given bytes of EMS memory from source handle, source
  logical page and source logical page offset to the given segment and offset.
  The source logical page offset must be in the range 0 to 16383 because a
  logical page is 16K in size. Refer to the EMS Section to get more info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMoveFromXMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMoveFromXMS (BYVAL Segment%, BYVAL Offset%, BYVAL Handle%, BYVAL XMSOffset&, BYVAL length&)


Parameters:

  -  Segment        Conventional memory segment
  -  Offset         Conventional memory offset
  -  Handle         Source XMS Handle
  -  XMSOffset      Source XMS offset
  -  Length         Length of memory to move (in bytes)


Description:

  This sub copies the given bytes from XMS handle, starting in the specified
  XMS offset, to the given segment and offset. The length must be even. Refer
  to the XMS Section to get more info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMoveToEMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMoveToEMS (BYVAL Segment%, BYVAL Offset%, BYVAL Handle%, BYVAL LogPage%, BYVAL PageOffset%, BYVAL Length&)


Parameters:

  -  Segment        Conventional memory segment
  -  Offset         Conventional memory offset
  -  Handle         Destiny EMS Handle
  -  LogPage        Destiny logical page
  -  PageOffset     Destiny logical page offset
  -  Length         Length of memory to move (in bytes)


Description:

  This sub copies the given bytes from the specified segment and offset to
  the given logical page in the EMS handle starting in the given logical page
  offset. The destiny logical page offset must be in the range 0 to 16383
  because a logical page is 16K in size. Refer to the EMS Section to get more
  info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMoveToXMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMoveToXMS (BYVAL Segment%, BYVAL Offset%, BYVAL Handle%, BYVAL XMSOffset&, BYVAL length&)


Parameters:

  -  Segment        Conventional memory segment
  -  Offset         Conventional memory offset
  -  Handle         Destiny XMS Handle
  -  XMSOffset      Destiny XMS offset
  -  Length         Length of memory to move (in bytes)


Description:

  This sub copies the given bytes from the given segment and offset to XMS
  handle, starting in the specified XMS offset. The length must be even. Refer
  to the XMS Section to get more info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSMoveXMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSMoveXMS (BYVAL SHandle%, BYVAL SOffset&, BYVAL DHandle%, BYVAL DOffset&, BYVAL Length&)


Parameters:

  -  SHandle        Source XMS Handle
  -  SOffset        Source XMS offset
  -  DHandle        Destiny XMS Handle
  -  DOffset        Destiny XMS offset
  -  Length         Length of EMS to move (in bytes)


Description:

  This sub copies the given bytes from the given source XMS handle, starting
  in the specified source XMS offset to destiny XMS handle, starting in the
  specified destiny XMS offset. The length must be even. If the memory overlap
  it is not guaranteed to work properly. Refer to the XMS Section to get more
  info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSNegativePal SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSNegativePal (BYVAL FirstCol%, BYVAL LastCol%)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index


Description:

  This sub inverses the colors between the first and last color indexes,
  producing a negatives effect.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPauseSound SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPauseSound ()


Description:

  This sub pauses a sound that is currently playing. If there is no sound
  playing then the result is undefined.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPcopy SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPcopy (BYVAL Source%, BYVAL Destiny%)


Parameters:

  -  Source        The source layer
  -  Destiny       The destiny layer


Description:

  This sub copies the given source layer to destiny layer. The data in destiny
  layer is lost. This is used to create double buffered animation and avoid
  flicker.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPcopyB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPcopyB (BYVAL Source%, BYVAL Destiny%)


Parameters:

  -  Source        The source layer
  -  Destiny       The destiny layer


Description:

  This sub copies transparently the given source layer to destiny layer. The
  data in destiny layer is blended to source layer using the current blender
  map. If there is not a blender map present this sub does nothing.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPcopyC SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPcopyC (BYVAL Source%, BYVAL Destiny%, BYVAL Col%)


Parameters:

  -  Source        The source layer
  -  Destiny       The destiny layer


Description:

  This sub copies transparently the given source layer to destiny layer. All
  non-zero pixels are drawn using the given color.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPcopyMMX SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPcopyMMX (BYVAL Source%, BYVAL Destiny%)


Parameters:

  -  Source         Source layer
  -  Destiny        Destiny layer


Description:

  The same as CSPcopy, this routine copies the source layer to the destiny
  layer to create double buffered animation, but this one uses MMX instructions
  to make the operation even faster. You have to call CSDetectMMX before using
  this routine.
  Don't worry, if the CPU doesn't support MMX instructions and you call this
  routine, CosmoX will not use MMX instructions, so the CPU won't crash, but
  for this to work, you have to call CSDetectMMX before any MMX routine.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPcopyT SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPcopyT (BYVAL Source%, BYVAL Destiny%)


Parameters:

  -  Source        The source layer
  -  Destiny       The destiny layer


Description:

  This sub copies transparently the given source layer to destiny layer. This
  can be useful to draw your sprites in one layer, your background in other
  layer and copying them to the screen. Also, to create a parallax scrolling
  effect.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPlaySound SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPlaySound (BYVAL SoundSeg%, BYVAL SoundOff&, BYVAL SoundSize&, BYVAL Freq&)


Parameters:

  -  SoundSeg      Segment of the sound to play
  -  SoundOff      Offset of the sound to play
  -  SoundSize     Size of the sound to play
  -  Freq          Frequency to play the sound with


Description:

  This sub plays the sound stored in the given buffer at the given frequency,
  the size of the sound tells how many bytes (samples) will be played. The
  sound is played with a DMA transfer so the sound will be played on the
  background while your program continues execution.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPoke SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPoke (BYVAL Segment%, BYVAL Offset%, BYVAL Value%)


Parameters:

  -  Segment          Segment to poke data to
  -  Offset           Offset to poke data to
  -  Value            INTEGER value to write


Description:

  This function works the same as QB POKE, but you specify the segment in the
  call, so it is more flexible.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPoke16 SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPoke16 (BYVAL Segment%, BYVAL Offset%, BYVAL Value%)


Parameters:

  -  Segment          Segment to poke data to
  -  Offset           Offset to poke data to
  -  Value            INTEGER value to write


Description:

  This function works the same as QB POKE, but you specify the segment in the
  call and it writes two bytes instead of one.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPoke32 SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPoke32 (BYVAL Segment%, BYVAL Offset%, BYVAL Value&)


Parameters:

  -  Segment          Segment to poke data to
  -  Offset           Offset to poke data to
  -  Value            LONG value to write


Description:

  This function works the same as QB POKE, but you specify the segment in the
  call and it writes four bytes instead of one.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPrint SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPrint (Layer%, X%, Y%, Text$, Col%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Text          Text to print
  -  Col           Color of the text


Description:

  This sub prints the given text on the given layer with the specified color.
  This sub uses the VGA BIOS font by default but you can use another font
  loaded with CSLoadFont or CSSetFont. The X and Y are pixels units instead of
  character cells like QB so you can put your text anywhere on the layer. This
  sub supports transparency so it will not draw the black box surrounding the
  text like QB. If you pass -1 or the CENTERED constant (see Library Constants
  Section) in the X parameter, the text will be centered on the screen. Also
  this sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPrintBlended SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPrintBlended (Layer%, X%, Y%, Text$, Col%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Text          Text to print
  -  Col           Color of the text


Description:

  This sub is the same as CSPrint, the difference is that this sub prints
  the text blending the colors with the current blender map. If there is not
  a blender map present this function does nothing.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPrintBold SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPrintBold (Layer%, X%, Y%, Text$, Col%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Text          Text to print
  -  Col           Color of the text


Description:

  This sub is the same as CSPrint, the difference is that this sub prints
  the text giving it a bold style.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPrintReversed SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPrintReversed (Layer%, X%, Y%, Text$, Col%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Text          Text to print
  -  Col           Color of the text


Description:

  This sub is the same as CSPrint, the difference is that this sub prints
  the text vertical mirrored.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPrintShadow SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPrintShadow (Layer%, X%, Y%, Text$, Col%, Shadow%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Text          Text to print
  -  Col           Color of the text
  -  Shadow        Color of the shadow


Description:

  This sub is the same as CSPrint, the difference is that this sub prints
  the text giving it a shadow effect using the Shadow color.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPrintSolid SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPrintSolid (Layer%, X%, Y%, Text$, FCol%, BCol%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Text          Text to print
  -  FCol          Foreground color of the text
  -  BCol          Background color of the text


Description:

  This sub is the same as CSPrint, the difference is that this sub prints
  the text solidly with the given colors, and it's not affected by the
  text spacing.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPrintTextured SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPrintTextured (Layer%, X%, Y%, Text$)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Text          Text to print


Description:

  This sub is the same as CSPrint, the difference is that this sub prints
  the text using the current text texture. The texture is 8x8 bitmap that
  tells CSPrintTextured with color it should use to draw a given pixel. The
  default texture is all pixels white, but this can be changed with
  CSTextTexture.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSProjectVector SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSProjectVector (BYVAL Vec3DSeg%, BYVAL Vec3DOff%, BYVAL Vec2DSeg%, BYVAL Vec2DOff%, BYVAL ZEye!)


Parameters:

  - Vec3dSeg         Segment of 3D vector to project
  - Vec3dOff         Offset of 3D vector to project
  - Vec2DSeg         Segment of 2D vector to store the projected values
  - Vec2DOff         Offset of 2D vector to store the projected values
  - ZEye             ZEye value (used in the projection formula)


Description:

  This sub projects the given 3D vector to a 2D vector to give the sense of
  3D perspective. The given 3D vector must be 3 single precision values, the
  first is X, the second Y and the third is Z. The 2D vector is two integer
  values, X and Y. There are 2 TYPES definitions in the INCLUDE file so you
  can use them instead (These are Vector3DType and Vector2DType).


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPset SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPset (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Col%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Col           Pixel color


Description:

  This sub sets the pixel (X, Y) in the given layer, with the specified color.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPsetB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPset (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Col%)


Parameters:

  -  Layer         The layer where to print
  -  X             X position of upper left corner of the first character
  -  Y             Y position of upper left corner of the first character
  -  Col           Pixel color


Description:

  This sub sets the pixel (X, Y) in the given layer, with the specified color
  using the blender map. If there isn't a blender map present then this routine
  does nothing. This routine is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSPushButton SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSPushButton (Layer%, X1%, Y1%, X2%, Y2%, ButCol%, TextCol%, Shadow%, Light%, Text$)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  ButCol        The button color
  -  TextCol       The text color
  -  Shadow        The button shadow
  -  Light         The button light
  -  Text          The button text


Description:

   This sub is used in conjunction with CSButton to give the effect of a
   pushing button, that is, you draw a button with CSButton and when your
   program detects a click on the button (or any other response) and you
   use CSPushButton with the same parameters that CSButton and you'll get
   a pushing effect.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSRemoveFfix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSRemoveFfix ()


Description:

  This routine turns of the fixup to QB's code. Don't forget to call this
  routine before exiting your programs if you use CSFfix. CSClose also
  removes this fixup, so if you use it at the end of your program you
  don't have to worry about it.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSRemoveKeyBoard SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSRemoveKeyBoard ()


Description:

  This sub turns off the custom keyboard handler. Don't forget to call this
  sub before exiting your programs and that when you turn off the custom
  keyboard handler the other keyboard routines won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSRemoveTimer SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSRemoveTimer ()


Description:

  This sub removes the CosmoX timer, resets all timer flags, and sets the
  system timer to its default frequency. When you call this sub, the other
  timer routines won't work (except CSInstallTimer, of course). You have
  to call this sub before exiting your program or it may crash the computer.
  See the section "Using the timers".


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSResetFont SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSResetFont ()


Description:

  This sub sets the current font to the old VGA BIOS characters set.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSResetMouse SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSResetMouse ()


Description:

  This sub sets the old mouse cursor, sets the mouse range to all the screen,
  and sets the default mouse speed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSResetTicks SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSResetTicks (BYVAL WhichTimer%)


Parameters:

  - WhichTimer     Timer to reset


Description:

  This sub resets the given timer tick counter. The tick counter holds the
  number of times the given timer has ticked since it was set. This sub
  won't work if the CosmoX timer hasn't been installed or the given timer
  hasn't been set.
  See the section "Using the timers".


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSRotatePalB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSRotatePalB (BYVAL FirstCol%, BYVAL LastCol%)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index


Description:

  This sub rotates backwards the palette in the given color indexes between
  FirstCol and LastCol. LastCol must be greater than FirstCol.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSRotatePalF SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSRotatePalF (BYVAL FirstCol%, BYVAL LastCol%)


Parameters:

  -  FirstCol      The first color index
  -  LastCol       The last color index


Description:

  This sub rotates the palette in the given color indexes between FirstCol and
  LastCol in a forward manner. LastCol must be greater than FirstCol.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSScroll SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSScroll (BYVAL Layer%, BYVAL Pixels%, BYVAL Direction%)


Parameters:

  -  Layer         Layer to scroll
  -  Pixels        Number of pixels to scroll
  -  Direction     Direction to scroll


Description:

  This sub scrolls the given layer the given number of pixels in the specified
  direction. The direction codes are as follow :  UP = 0, DOWN = 1, LEFT = 2,
  RIGHT = 3, there are some constants to make this easy too. The scrolled area
  will be filled with garbage so is up to you to draw new graphics.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSScrollArea SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSScrollArea (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL Direction%)


Parameters:

  -  Layer         Layer to scroll
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  Direction     Direction to scroll


Description:

  This sub scrolls the area in the given layer formed by the box (X1, Y1) -
  (X2, Y2). It scrolls one pixel at a time in the given direction. The
  direction codes are as follow :  UP = 0, DOWN = 1, LEFT = 2, RIGHT = 3, there
  are some constants to make this easy too. The scrolled area will be filled
  with garbage so is up to you to draw new graphics.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSScrollHEMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSScrollHEMS (BYVAL Layer%, BYVAL XOffset%, BYVAL Handle1%, BYVAL LogPage1%, BYVAL Handle2%, BYVAL LogPage2%)


Parameters:

  -  Layer         Layer where to show the scrolled backgrounds
  -  XOffset       X offset to scroll
  -  Handle1       The handle to the first background
  -  LogPage1      The logical page on the handle where the second BG starts
  -  Handle2       The handle to the second background
  -  LogPage2      The logical page on the handle where the second BG starts


Description:

  This routine draws the 2 backgrounds stored on EMS using the XOffset to
  give an horizontal scrolling effect. Be sure that the given handles and
  logical pages are valid, or this sub may crash, also, the 2 backgrounds
  can be stored on the same handle, you just have to specify their correct
  logical page. This routine has a lot of potential, make sure to play
  with it so you can understand what I mean.
  Note: The destiny layer must not be on EMS!


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSScrollVEMS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSScrollVEMS (BYVAL Layer%, BYVAL XOffset%, BYVAL Handle1%, BYVAL LogPage1%, BYVAL Handle2%, BYVAL LogPage2%)


Parameters:

  -  Layer         Layer where to show the scrolled backgrounds
  -  XOffset       X offset to scroll
  -  Handle1       The handle to the first background
  -  LogPage1      The logical page on the handle where the second BG starts
  -  Handle2       The handle to the second background
  -  LogPage2      The logical page on the handle where the second BG starts


Description:

  This routine draws the 2 backgrounds stored on EMS using the XOffset to
  give a vertical scrolling effect. Be sure that the given handles and
  logical pages are valid, or this sub may crash, also, the 2 backgrounds
  can be stored on the same handle, you just have to specify their correct
  logical page. This routine has a lot of potential, make sure to play
  with it so you can understand what I mean.
  Note: The destiny layer must not be on EMS!


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetBMap FUNCTION  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetBMap (BYVAL ForeColor%, BYVAL BackColor%, BYVAL NewColor%)


Parameters:

  -  ForeColor      The Foreground Color
  -  BackColor      The Background Color
  -  NewColor       The color to set


Description:

   This sub sets in the blender map the given combination of forecolor and
   background color to the specified color. This makes it easy to create a lot
   of effects, like translucency. If there isn't a blender map, this sub does
   nothing. If you don't understand what's a blender map refer to the Blender
   Map Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetClipBox SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetClipBox (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%)


Parameters:

  -  X1            Upper left X coordinate
  -  Y1            Upper left Y coordinate
  -  X2            Lower right X coordinate
  -  Y2            Lower right Y coordinate


Description:

  This sub sets the clip box coordinates to the given ones.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetCol SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetCol (BYVAL Col%, BYVAL Red%, BYVAL Green%, BYVAL Blue%)


Parameters:

  -  Col           Color index to get the hues from
  -  Red           The new red hue
  -  Green         The new green hue
  -  Blue          The new blue hue


Description:

  This sub sets the red, green and blue hues of the given color.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetDrive SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetDrive (Drive$)


Parameters:

  -  Drive           A character that represents the new drive letter


Description:

  This sub sets the current drive to the given one. The parameter is a
  character that represents the drive, like "A" will set drive A, and so on.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetFont SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetFont (Font$)


Parameters:

  -  Font          The new font to set


Description:

  This sub sets the given font as the next to be used by the text functions.
  The Font passed must be a 2048 characters string holding the graphic data
  of the font. To see more about the format used by the fonts functions refer
  to the Library Formats Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetMouseCursor SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetMouseCursor (HotX%, HotY%, Cursor$)


Parameters:

  -  HotX          The hot X coordinate of the cursor
  -  HotY          The hot Y coordinate of the cursor
  -  Cursor        64 characters STRING holding the new cursor to set


Description:

  This sub sets the mouse cursor shape to the given one. The cursor must be a
  64 characters string holding the screen mask and the xor mask. To see more
  about  the cursor format refer to the Library Formats Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetMouseRange SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetMouseRange (BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%)


Parameters:

  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate


Description:

  This sub sets the mouse range to the given one. This is, the mouse cursor
  won't go out of the given box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetMouseSpeed SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetMouseSpeed (BYVAL XSpeed%, BYVAL YSpeed%)


Parameters:

  -  XSpeed        The horizontal speed (default 8)
  -  YSpeed        The vertical speed (default 16)


Description:

  This sub sets the mouse vertical and horizontal speed to the new given ones.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetMouseXY SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetMouseXY (BYVAL X%, BYVAL Y%)


Parameters:

  -  X             New X coordinate
  -  Y             New Y coordinate


Description:

  This sub sets the mouse in the given position.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetPal SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetPal (Pal$)


Parameters:

  -  Pal           768 characters string holding the palette


Description:

  This sub sets the current palette to the new given one. For details in the
  format refer to the Library Formats Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetTextSpacing SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetTextSpacing (BYVAL TextSpacing%)


Parameters:

  -  TextSpacing        INTEGER value holding the new text spacing


Description:

  This sub changes the text spacing to the new specified one. The default
  spacing is 8, if you decrease this value you'll get a more compact text
  printed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSetTimer SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSetTimer (BYVAL WhichTimer%, BYVAL Millisecs&)


Parameters:

  - WhichTimer     Timer to set
  - Millisecs      The number of milliseconds the timer will run


Description:

  This sub sets the given timer to the given frequency (in milliseconds).
  You can have up to 16 timers (numbered 0 to 15). The numbers of given
  milliseconds must be a multiple of 5 or it won't be updated accurately,
  I have done it this way so Windows won't complain about it (telling that
  your program should run in DOS mode).
  The frequency can be of 5 milliseconds up to 2147483645 (596 hours I guess),
  when the given time has passed a flag will be set for that timer (you can
  check that flag with CSTimerFlag), and a counter will be incremented (you
  can check that counter with CSElapsedTicks). This sub won't work if the
  CosmoX timer hasn't been installed.
  See the section "Using the timers".


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSort SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSort (BYVAL RecordSeg%, BYVAL RecordOff%, BYVAL NumOfRecords%, BYVAL SizeOfRecord%, BYVAL IndexKey%)


Parameters:

  -  RecordSeg          The record segment
  -  RecordOff          The record offset
  -  NumOfRecords       Number of records in the array
  -  SizeOfRecords      Record size (must be multiple of 2)
  -  IndexKey           Offset of the index key (must be integer)


Description:

  This sub sorts an array of records using an optimized bubble sort. The
  array of records can be of any size but it must be a multiple of 2. There
  is no limit on the  number of records that can be sorted. The RecordSeg and
  RecordOff parameters specify the memory location of the first record to be
  sorted, it sorts the given number of records, IndexKey is the offset in
  the record of an INTEGER value to be used as the sort key.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSprite SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSprite (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This puts the sprite stored in the given array on the given layer, at the
  specified coordinates. This sub works almost like PUT but doesn't draw color
  0, allowing transparency. Also, this sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteB (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This sub works like CSSprite but it will blend the colors using the current
  blender map. If there isn't a blender map present this sub does nothing.
  Refer to the Blender Map section for more info.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteC SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteC (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&, BYVAL Col%)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data
  -  Col           Color to use on the sprite


Description:

  This sub works like CSSprite but it will draw all non-zero colors using the
  given color. Useful to show when an enemy has been hit or for lightning
  effects.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteF SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteF (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This sub works also puts a sprite but it uses a very fast algorithm and
  doesn't support clipping and transparency. It is optimized if your sprites
  are power of two or four (If they are a power of 4, this will fly).


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteFlipH SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteFlipH (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This sub works like CSSprite but it will draw a horizontally flipped sprite.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteFlipV SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteFlipV (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This sub works like CSSprite but it will draw a vertically flipped sprite.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteFlipped SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteFlipped (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This sub works like CSSprite but it will draw the sprite both vertically and
  horizontally flipped.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteN SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteN (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This puts the sprite stored in the given array on the given layer, at the
  specified coordinates. This sub works the same as PUT because it doesn't
  support color-0 transparency, but it supports clipping. This routine is
  very fast, so use whenever you dont need transparency but you need
  clipping, if you dont need it neither then use CSSpriteF.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteO SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteO (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Segment%, BYVAL Offset&, BYVAL Operation%)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data
  -  Operation     Bit wise operation to perform


Description:

  This sub works like CSSprite but it will apply the specified bit wise
  operation when placing the sprite. The operation codes are as follow :
  XOR = 0, AND = 1, OR = 2. There are also some constant too make it easy,
  refer to the Library Constants Section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteR SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteR (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL Angle%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  Angle         The angle of rotation (0-359)
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This sub rotates the sprite pointed by Segment and Offset, it supports
  transparency and clipping. The angle must be 0-359 or you will get
  garbage.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteRZ SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteRZ (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL NewWidth%, BYVAL NewHeight%, BYVAL Angle%, BYVAL Segment%, BYVAL Offset&)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  NewWidth      New sprite width
  -  NewHeight     New sprite height
  -  Angle         The angle of rotation (0-359)
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  Like the last one, this routines rotates the given sprite, but it also
  scales it to the given width and height. This is, it applies a roto-zooming
  effect. This routine supports clipping and transparency. Don't forget that
  the angle must be (0-359).


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSSpriteS SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSSpriteS (BYVAL Layer%, BYVAL X%, BYVAL Y%, BYVAL NewWidth%, BYVAL NewHeight%, BYVAL Segment%, BYVAL Offset%)


Parameters:

  -  Layer         The layer were to put the sprite
  -  X             The upper left X position of the sprite
  -  Y             The upper left Y position of the sprite
  -  NewWidth      New sprite width
  -  NewHeight     New sprite height
  -  Segment       The segment of the array holding the sprite data
  -  Offset        The Offset of the array holding the sprite data


Description:

  This sub works like CSSprite but it will draw a scaled sprite with the
  given dimensions. You can easily stretch and shrink a sprite with this sub.
  This sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTextTexture SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTextTexture (BYVAL Segment%, BYVAL Offset%)


Parameters:

  -  Segment       The segment of the array holding the texture data
  -  Offset        The Offset of the array holding the texture data


Description:

  This sub sets the font texture used by CSPrintTextured. The array must be
  64 bytes long, the texture is a 8x8 bitmap that shows CSPrintTextured what
  color to use in the a given pixel. The most easy way to fill a texture is by
  some DATA statements and READ them in an INTEGER array. Refer to the Library
  Formats Section to get more info and some examples.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTextureWidth SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTextureWidth (BYVAL NewWidth%)


Parameters:

  -  NewWidth      New width of texture to use with texture mapping


Description:

  This sub sets the width of texture to use on subsequent calls to the
  textured triangle routines (CSTriT, CSTriTB, CSTriTF). The width must be a
  power of 2, the maximum width is 256, if you give a greater value it will be
  rounded, all others values will be rounded to the last power of 2 (i.e. 156
  will be 128, 70 will be 64, etc.). The default value is 64.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTri SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTri (Layer%, X1%, Y1%, X2%, Y2%, X3%, Y3%, Col%)


Parameters:

  -  Layer         Layer to draw on
  -  X1            X coordinate of the first point
  -  Y1            Y coordinate of the first point
  -  X2            X coordinate of the second point
  -  Y2            Y coordinate of the second point
  -  X3            X coordinate of the third point
  -  Y3            Y coordinate of the third point
  -  Col           Color the triangle


Description:

  This sub draws an empty triangle on the given layer with the given color.
  (X1,Y1), (X2, Y2) and (X3, Y3) are the vertexes of the triangle. This sub is
  affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTriF SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTriF (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL X3%, BYVAL Y3%, BYVAL Col%)


Parameters:

  -  Layer         Layer to draw on
  -  X1            X coordinate of the first point
  -  Y1            Y coordinate of the first point
  -  X2            X coordinate of the second point
  -  Y2            Y coordinate of the second point
  -  X3            X coordinate of the third point
  -  Y3            Y coordinate of the third point
  -  Col           Color the triangle


Description:

  This sub draws a flat-shaded triangle on the given layer with the given
  color. (X1,Y1), (X2, Y2) and (X3, Y3) are the vertexes of the triangle. This
  sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTriFB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTriFB (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL X3%, BYVAL Y3%, BYVAL Col%)


Parameters:

  -  Layer         Layer to draw on
  -  X1            X coordinate of the first point
  -  Y1            Y coordinate of the first point
  -  X2            X coordinate of the second point
  -  Y2            Y coordinate of the second point
  -  X3            X coordinate of the third point
  -  Y3            Y coordinate of the third point
  -  Col           Color the triangle


Description:

  This sub draws a flat-shaded triangle on the given layer with the given
  color. (X1,Y1), (X2, Y2) and (X3, Y3) are the vertexes of the triangle. The
  colors are blended with the background using the current blender map. If
  there isn't a blender map present this function does nothing. This sub is
  affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTriG SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTriG (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL Col1%, BYVAL X2%, BYVAL Y2%, BYVAL Col2%, BYVAL X3%, BYVAL Y3%, BYVAL Col3%)


Parameters:

  -  Layer         Layer to draw on
  -  X1            X coordinate of the first point
  -  Y1            Y coordinate of the first point
  -  Col1          Color of the first point
  -  X2            X coordinate of the second point
  -  Y2            Y coordinate of the second point
  -  Col1          Color of the second point
  -  X3            X coordinate of the third point
  -  Y3            Y coordinate of the third point
  -  Col3          Color the third point


Description:

  This sub draws a gouraud-shaded triangle on the given layer with the given
  colors. (X1,Y1), (X2, Y2) and (X3, Y3) are the vertexes of the triangle. Col1,
  Col2 and Col3 are the colors of their respective vertexes. This sub is
  affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTriGB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTriGB (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL Col1%, BYVAL X2%, BYVAL Y2%, BYVAL Col2%, BYVAL X3%, BYVAL Y3%, BYVAL Col3%)


Parameters:

  -  Layer         Layer to draw on
  -  X1            X coordinate of the first point
  -  Y1            Y coordinate of the first point
  -  Col1          Color of the first point
  -  X2            X coordinate of the second point
  -  Y2            Y coordinate of the second point
  -  Col1          Color of the second point
  -  X3            X coordinate of the third point
  -  Y3            Y coordinate of the third point
  -  Col3          Color the third point


Description:

  This sub draws an gouraud-shaded triangle on the given layer with the given
  colors. (X1,Y1), (X2, Y2) and (X3, Y3) are the vertexes of the triangle. Col1,
  Col2 and Col3 are the colors of their respective vertexes. The colors are
  blended with the background, if there isn't a blender map present this sub
  does nothing. This sub is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTriT SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTriT (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL X3%, BYVAL Y3%, BYVAL U1%, BYVAL V1%, BYVAL U2%, BYVAL V2%, BYVAL U3%, BYVAL V3%, BYVAL TSeg%, BYVAL TOff%)


Parameters:


  -  Layer       Layer where to draw the triangle
  -  X1          X coordinate of the first vertex
  -  Y1          Y coordinate of the first vertex
  -  X2          X coordinate of the second vertex
  -  Y2          Y coordinate of the second vertex
  -  X3          X coordinate of the third vertex
  -  Y3          Y coordinate of the third vertex
  -  U1          X coordinate of first vertex on texture
  -  V1          Y coordinate of first vertex on texture
  -  U2          X coordinate of second vertex on texture
  -  V2          Y coordinate of second vertex on texture
  -  U3          X coordinate of third vertex on texture
  -  V3          Y coordinate of third vertex on texture
  -  TSeg        Array segment holding the texture (use VARSEG)
  -  TOff        Array offset holding the texture (use VARPTR)


Description:

  This sub draws an texture-mapped triangle on the given layer with the given
  texture. (X1,Y1), (X2, Y2) and (X3, Y3) are the vertexes of the triangle.
  The texture used must be stored in the array with GET or CSGet, and it's
  width must be a power of 2 and equal to the last call to CSTextureWidth
  (default it's 64). Each vertex has it's own texture coordinates that can be
  anywhere on the texture. This is affected by the clipping box.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTriTB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTriTB (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL X3%, BYVAL Y3%, BYVAL U1%, BYVAL V1%, BYVAL U2%, BYVAL V2%, BYVAL U3%, BYVAL V3%, BYVAL TSeg%, BYVAL TOff%)


Parameters:


  -  Layer       Layer where to draw the triangle
  -  X1          X coordinate of the first vertex
  -  Y1          Y coordinate of the first vertex
  -  X2          X coordinate of the second vertex
  -  Y2          Y coordinate of the second vertex
  -  X3          X coordinate of the third vertex
  -  Y3          Y coordinate of the third vertex
  -  U1          X coordinate of first vertex on texture
  -  V1          Y coordinate of first vertex on texture
  -  U2          X coordinate of second vertex on texture
  -  V2          Y coordinate of second vertex on texture
  -  U3          X coordinate of third vertex on texture
  -  V3          Y coordinate of third vertex on texture
  -  TSeg        Array segment holding the texture (use VARSEG)
  -  TOff        Array offset holding the texture (use VARPTR)


Description:

  This sub is the same as CSTriT, but it draws the triangle using the current
  blender map. If there is no blender map this sub does nothing.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTriTF SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTriTF (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL X3%, BYVAL Y3%, BYVAL U1%, BYVAL V1%, BYVAL U2%, BYVAL V2%, BYVAL U3%, BYVAL V3%, BYVAL TSeg%, BYVAL TOff%)


Parameters:


  -  Layer       Layer where to draw the triangle
  -  X1          X coordinate of the first vertex
  -  Y1          Y coordinate of the first vertex
  -  X2          X coordinate of the second vertex
  -  Y2          Y coordinate of the second vertex
  -  X3          X coordinate of the third vertex
  -  Y3          Y coordinate of the third vertex
  -  U1          X coordinate of first vertex on texture
  -  V1          Y coordinate of first vertex on texture
  -  U2          X coordinate of second vertex on texture
  -  V2          Y coordinate of second vertex on texture
  -  U3          X coordinate of third vertex on texture
  -  V3          Y coordinate of third vertex on texture
  -  TSeg        Array segment holding the texture (use VARSEG)
  -  TOff        Array offset holding the texture (use VARPTR)


Description:

  This sub is the same as CSTriT (texture-mapped triangle), but applies
  bilinear-filtering when drawing so you get better looking triangles, the
  only problem is that it has some drawbacks and rules, like:

  - It is a little slower than CSTriT, it does some adds and shifts to
    calculate a pixel, though this isn't that bad. (DQB uses 8 multiplies)
  - You need a gradient palette.
  - You need to create your textures using colors that are near themselves,
    this is, if you draw a pixel with color 84 then don't draw the next pixel
    with color 3, because the routine averages the pixels.
  - When you give the U and V coordinates (in texture space) don't give the
    the edges as coordinates, for example, if your texture is 64x64 then
    don't give the coordinates 0,0 - 63,0 - 63,63, give something like
    1,1 - 62,1 - 62,62, this way the routine is not going to average pixels
    outside the texture.

  If you follow these rules then you'll get cool-looking texture-mapped
  triangles with the best use of the palette.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTurnBlasterOn SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTurnBlasterOn ()


Description:

  This sub enables the sound card speaker. If the speaker is disabled then no
  sound will be heard.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSTurnBlasterOff SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSTurnBlasterOff ()


Description:

  This sub disables the sound card speaker. If the speaker is disabled then
  no sound will be heard.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSUnitVector SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSUnitVector (BYVAL SVecSeg%, BYVAL SVecOff%, BYVAL DVecSeg%, BYVAL DVecOff%)


Parameters:

  - SVecSeg%        Segment of first vector
  - SVecOff%        Offset of first vector
  - DVecSeg%        Segment of second vector
  - DVecOff%        Offset of second vector


Description:

  Given a vector this sub calculates its unit vector, this is, that it ranges
  between -1 and 1, again, this thing is used a lot in 3D graphics.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSVectorMulMatrix SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSVectorMulMatrix (BYVAL SVecSeg%, BYVAL SVecOff%, BYVAL MatSeg%, BYVAL MatOff%, BYVAL DVecSeg%, BYVAL DVecOff%)


Parameters:

  - SVecSeg            Segment of the source vector
  - SVecOff            Offset of the source vector
  - MatSeg             Segment of the 4x4 transformation matrix
  - MatOff             Offset of the 4x4 transformation matrix
  - DVecSeg            Segment of the destiny 4x4 matrix
  - DVecOff            Offset of the destiny vector


Description:

  This routine transforms the source vector by the transformation matrix, this
  is, it multiplies them together. The result is placed in the destiny vector.
  The vector must be 3 single precision numbers, the first number is X, the
  second is Y and the third is Z.
  The matrix must be a 4x4 array of single precision floating-point numbers.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWaitKey SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWaitKey (BYVAL ScanCode%)


Parameters:

  -  ScanCode      Scan code to wait for


Description:

  This sub waits for the user to press the key with the given scan code. If you
  pass -1 or the ANYKEY constant, this sub waits for the user to press any key.
  This sub only works when the custom keyboard handler is installed.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWaitRetrace SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWaitRetrace ()


Description:

  This sub waits for the monitor vertical retrace.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWaitTimer SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWaitTimer (BYVAL WhichTimer%)


Parameters:

  - WhichTimer     Timer to wait


Description:

  This sub waits till the flag of the given timer is set, this is, it waits
  till its next tick. This sub won't work if the CosmoX timer hasn't been
  installed or if the given timer hasn't been set.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWin SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWin (BYVAL Layer%, BYVAL X1%, BYVAL Y1%, BYVAL X2%, BYVAL Y2%, BYVAL WinCol%, BYVAL Shadow%, BYVAL Light%)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  WinCol        The window color
  -  Shadow        The window shadow
  -  Light         The window light


Description:

  This sub draws something like a window but with any display on it. It just
  draws an empty window on the given layer and with the given color in the
  specified coordinates. The shadow and light parameters are the colors that
  give the window a 3D appearance. The points must be X1 < X2 and Y1 < Y2.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinAppSetTitle SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWinAppSetTitle (Title$)


Parameters:

  -  Title         Title to set


Description:

  This sub changes the title of the current DOS application, regardless
  of its last title.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinCloseClipB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWinCloseClipB ()


Description:

  This sub closes a previously open path of communication to the Windows
  clipboard (see CSWinOpenClipB). You should always call this routine before
  exiting your programs.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinEmptyClipB SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWinEmptyClipB ()


Description:

  This sub empties the Windows clipboard, also, you should close the clipboard
  before exiting your programs, using CSWinCloseClipB.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinFindClose SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWinFindClose ()


Description:

  This sub closes the handle of the last file searching using Windows calls
  (see CSWinFindFile and CSWinFindNext). This routine should be called after
  every directory scan session, because it frees a handle given by Windows
  to CosmoX.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinGetClipBData SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWinGetClipBData (BYVAL Segm%, BYVAL Offs&, BYVAL TypeOfData%)


Parameters:

  -  Segm          Segment of the address where the data will be stored
  -  Offs          Offset of the address where the data will be stored
  -  TypeOfData    Type of data


Description:

  This routine retrieves the data of the given type stored on the Windows
  clipboard on the given address. You should check if there is that type of
  data available using CSWinGetClipBDataType. Also, be sure that the buffer
  is longer enough to hold the data, you can check the size of the data
  using CSWinGetClipBDataSize. To see the types of data you can get take
  a look at the CosmoX Constants Section. Please check the CosmoX TYPE
  definitions to see the headers that should be read (and written) when
  dealing with the Windows clipboard.
  You should close the clipboard before exiting your programs, using
  CSWinCloseClipB.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinSetClipBData SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWinSetClipBData (BYVAL Segm%, BYVAL Offs&, BYVAL TypeOfData%, BYVAL SyzeOfData&)


Parameters:

  -  Segm          Segment of the address where the data will be read
  -  Offs          Offset of the address where the data will be read
  -  TypeOfData    Type of data
  -  SizeOfData    Size of data


Description:

  This routine stores the data of the given type on the Windows clipboard
  from the given address. Please check the CosmoX TYPE definitions to see
  the headers that should be written (and read) when dealing with the
  Windows clipboard.
  To see the types of data you can set take look at the CosmoX Constants
  Section. You should close the clipboard before exiting your programs, using
  CSWinCloseClipB.
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWinVMSetTitle SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWinVMSetTitle (Title$)


Parameters:

  -  Title         Title to set


Description:

  This sub changes the title of the Virtual Machines that runs DOS programs,
  regarless of the last title. When you change this title, it remains forever
  unless you change it back or change it on the settings of the program (the
  .PIF file), so if you change it, be sure to change it back to whatever it
  was (see CSWinVMGetTitle)
  You should call CSDetectWin before using this function. Obviously, if you
  are not running under Windows this won't work.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  CSWindow SUB  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

Prototype :

  DECLARE SUB CSWindow (Layer%, X1%, Y1%, X2%, Y2%, WinCol%, HeadCol%, TextCol%, Shadow%, Light%, Text$)


Parameters:

  -  Layer         The layer to draw on
  -  X1            The upper left X coordinate
  -  Y1            The upper left Y coordinate
  -  X2            The lower right X coordinate
  -  Y2            The lower right Y coordinate
  -  WinCol        The window color
  -  HeadCol       The header color
  -  TextCol       The text color
  -  Shadow        The window shadow
  -  Light         The window light
  -  Texts         Text to use like a header


Description:

  This sub draws a window in the given layer on specified coordinates with
  given color. The text color will be used printing the text header, the
  header color is the color used in the header rectangle. Text is the text to
  use like a header. The text will be centered on the header just make sure it
  fits. The shadow and light parameters are colors used to give the window a 3D
  appearance. The points must be X1 < X2 and Y1 < Y2. This is a very useful
  sub and the better way to understand it is seeing in action.


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - EMS Memory -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  Introduction  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  Normally in your QuickBASIC programs, you can only access conventional
  memory, that is, the first 640K of memory, this is because a long time
  ago when the people at Intel were designing their first processor they
  decided that it could only access 1MB of memory (that was a lot of memory
  back then!).
  The first 640K of memory is the memory that DOS and DOS programs use, the
  memory remaining between 640K and 1 MB is called HIMEM, and is used for
  other purposes like to load drivers, video memory, etc.
  That's the reason why a normal program can only access this memory,
  obviously when more people started to make bigger and bigger programs
  the need for more memory was huge, so people at Intel, MicroSoft and Lotus
  created the Expanded Memory System (EMS), with this system you can access
  memory above 1 MB all the way to 32 MB.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  How expanded memory works  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  Expanded memory is divided into segments called logical pages. These pages
  are 16K bytes of memory. Your computer accesses logical pages through a
  physical block of memory called a page frame. The page frame contains
  multiple physical pages, pages that the microprocessor can address directly.
  Physical pages are also typically 16K bytes of memory.

  The page frame serves as a window into expanded memory. Just as your computer
  screen is a window into a large spreadsheet, so the page frame is a window
  into expanded memory.

  A logical page of expanded memory can be mapped into (made to appear in) any
  one of the physical pages in the page frame.  Thus, a read or write to the
  physical page actually becomes a read or write to the associated logical
  page.  One logical page can be mapped into the page frame for each physical
  page.

  (I ripped this last part from the EMS specification)

  What means all that?, well, suppose you want to allocate a layer. In mode 13h
  this layer has to be 64K in size (320 x 200 = 64000), given that a logical
  page of EMS is 16K then you allocate 4 pages, that's 4 * 16 = 64K. Now you
  have the memory to use like a layer but how you access it?. Well like the
  part above says, you map this 64K of memory to a 64K of memory in the HIMEM
  called the page frame so the processor can access it, then you get the page
  frame address and there you have it. The layer is ready to use. Now you can
  read and write to the page frame and it will be like writing directly to
  your memory.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  EMS Layers  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  If you don't know why the heck would you like a layer think on this, you
  draw something in the screen, then you clear it to draw your next thing, and
  you do it again, what you see ??, FLICKER!!!. The screen is flickering
  constantly because you have the time to see the screen clearing. This looks
  ugly. With EMS you just set up a layer (or as many as you want) and get the
  page frame address. Now instead of passing the video memory address to
  the library functions, pass the page frame address, obviously you don't see
  anything because you are drawing in a offscreen layer, but now you copy
  your layer all at a time to the video memory, clear the layer, start drawing
  on it, copy it again to video memory and so on, and what you get ??...
  flickerless animation!!!!.

  The page frame is 64K size so you can only have a layer at a time. So to
  have more than one layer, you have to be constantly remapping them.
  The page frame is divided in 4 pages of 16K of memory just like the size of
  the logical pages of EMS. To setup a layer just do this :


  We make sure there is a Expanded Memory manager so our program won't crash.

  IF CSDetectEMS = 0 THEN
    PRINT "You need an EMS Manager to run this program!!"
    END
  END IF

  We allocate 4 logical pages ( 4 * 16K = 64K = 1 layer).

  Handle% = CSAllocateEMS(4)

  We make sure there is a free EMS so our program won't crash.

  IF Handle% = 0 THEN
    PRINT "You need 64K of free EMS to run this program!!"
    END
  END IF

  Then we get the page frame address and store it in the Layer% variable.

  Layer% = CSGetEMSFrame

  We map the EMS memory, we have pass the Handle we get from CSAllocateEMS
  so the function can know which memory to map.

  CSMapEMSLayer Handle%, 0

  Note: CSMapEMSLayer maps 4 logical pages to the 4 pages in the page frame
  so if the Handle passed doesn't have at least 4 logical pages, your program
  may crash.

  Now that our layer is mapped and is accessible we clear our layer so it
  doesn't have any garbage.

  CSClear Layer%, 0

  And we draw something to it.

  CSPrint Layer%, 5, 100, "Expanded memory is useful!!", 15

  Now we pass it to the screen

  CSPcopy Layer%, VIDEO


  But what happens if I want more than one layer ??.
  You allocate more memory for them and map them one at a time.

  1 layers = 4 logical pages
  2 layers = 8 logical pages
  3 layers = 12 logical pages
  and so on.

  Get the address and allocate mmmm... 3 layers.

  Layer% = CSGetEMSFrame
  Handle% = CSAllocateEMS(12)

  We map the first layer and draw to it.

  CSMapEMSLayer Handle%, 0
  CSClear Layer%, 0
  CSPrint Layer%, 5, 100, "Layer 1", 15

  We map the second layer and draw to it.

  CSMapEMSLayer Handle%, 4
  CSClear Layer%, 0
  CSPrint Layer%, 5, 100, "Layer 2", 15

  We map the third layer and draw to it.

  CSMapEMSLayer Handle%, 8
  CSClear Layer%, 0
  CSPrint Layer%, 5, 100, "Layer 3", 15

  Did you see how I mapped them?
  I allocated 12 pages ok?, then I map the first, so I give CSMapEMSLayer
  my EMS handle and the logical page where to start mapping. I give 0 the
  first time because it is zero relative, so it maps the first four pages
  that make my first layer, I clear it and print a message on it.
  Then I map the second layer, this time I pass 4 as the logical page where
  to start mapping this is because the 0, 1, 2, and 3 are the first layer,
  so 4, 5, 6, and 7 are the second, so when I map the third layer I give
  8 as the page where to start so 8, 9, 10, and 11 are my third layer.
  Very easy, isn't it?

  Just don't forget to free the memory you allocate so other programs can
  use it. If you take memory and you don't return it your program will look
  very unprofessional.

  You free it like this :

  CSDeallocateEMS Handle%

  You have to do this with any handle you may have allocated. I suggest you
  to use only 1 handle and allocate all your memory on it so you don't have
  trouble.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  Custom data on EMS  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ

  Well, just like I said, you can use EMS for your custom data.
  This is the same as with layers, the only difference it's on the data.

  Well, let's suppose that we are making a game. This game has a lot of
  sprites so it can have a very smooth animation. Let's suppose that we
  have also various palettes, some mouse cursors, some fonts and why not
  some sounds. All this things are going to hog lot of memory, and we are
  running on the risk of getting out of memory for our other variables, what
  do we do???

  Obviously we can store it all in EMS memory!!!, this way we can have
  a lot of data and we still have our 640K to do some other things on it.

 An approach could be to save all your data on disk files, then allocate
 the memory you need at run-time, map it and load them in at the beginning
 of your program. This way you can have all your data at handy. If you were
 to do this on conventional memory and with some Megabytes of data you will
 have to load some of the data from the disk whenever you need it and that
 will really slow your program.

 Let's suppose you need a Megabyte of memory. First you check for the memory
 manager so your program doesn't crash, then you allocate 64 logical pages.

 Handle% = CSAllocateEMS(64)  'Handle% doesn't need to be the name of the
                              'variable, you can use whatever you want

 You can map an entire 64K segment with CSMapEMSLayer, but you can also map
 one logical page at a time with CSMapEMS. This sub lets you map any logical
 page on your handle to any of the 4 physical pages on the page frame. This
 is useful when your data doesn't fit in 64K.

 You must call it like this :

  CSMapEMS Handle%, PhyPage%,  LogPage%

  Where PhyPage is the physical page (0-3) where to map it on the page frame
  and LogPage that is the logical page to map.
  So if you want to map your 20th logical page on the first physical page
  then you do the following :

  CSMapEMS Handle%, 0,  19   'Remember that logical pages are zero relative
                             'when mapping.

  A word of caution is that if you map in a specific physical page and you
  don't fill the whole page frame, then you must use the right offset when
  writing or reading to this memory, otherwise, you can write on memory mapped
  before or crash your system.

  Remember that a physical page is 16K so the offsets are:

  0h    - 3FFFh   First physical page offset   (the h at the end is to
  4000h - 7FFFh   Second physical page offset   represent hex numbers)
  8000h - BFFFh   Third physical page offset
  C000h - FFFFh   Fourth physical page offset

  So if you map memory on the second physical page, to access it you first
  get the segment of the page frame with CSGetEMSFrame then you use the
  offset of the second physical page to form the whole address.

  So to POKE in your EMS memory in QB :

  PageFrame% = CSGetEMSFrame

  DEF SEG = PageFrame%

  POKE &H4000, MyVar%

  Well, I think this is all for this section, but obviously POKEing your
  data to the EMS memory is very inefficient.
  So to avoid this better read the next section.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  Moving data on, from and to EMS  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  First of all, before you read this part first read the last ones because
  this builds on the previous parts.

  There are three types of moves you can do in EMS :

  -  From EMS to EMS
  -  From EMS to conventional memory
  -  From conventional memory to EMS

  These routines are very useful when dealing with custom data on EMS.

  Let's suppose you have a palette file and you want to store it on EMS.
  You first load your palette in memory with CSLoadPal (refer to the functions
  reference). Then you just move it to EMS. This is as easy as it sounds.


  First we make sure there is a Expanded Memory manager so our program won't
  crash.

  IF CSDetectEMS = 0 THEN
    PRINT "You need an EMS Manager to run this program!!"
    END
  END IF

  We allocate 1 logical page

  Handle% = CSAllocateEMS(1)

  We make sure there is a free EMS so our program won't crash.

  IF Handle% = 0 THEN
    PRINT "You need 16K of free EMS to run this program!!"
    END
  END IF

  Now that all it's ok we load our palette

  DIM Pal AS STRING * 768

  IF CSLoadPal("PALETTE.PAL", Pal) <> 0 THEN
    PRINT "Could not load PALETTE.PAL"
    END
  END IF

  Now we move it to EMS

  CSMoveToEMS VARSEG(Pal), VARPTR(Pal), Handle%, 0, 0, 768

  First we pass the segment of the palette, next the offset, next the handle
  of the memory, next the logical page I used zero because they are zero
  relative, next the offset of the logical page (must be 0-3FFFh remember that
  a page is 16K), and last the number of bytes to move.
  Easy uh??, you can copy up to 1MB of data this way but make sure you have
  allocated enough memory and you give the right logical page (in other words
  make sure there are enough logical pages after the one you give to the
  routine).

  To retrieve your data do the following :

  DIM Pal2 AS STRING * 768

  CSMoveFromEMS VARSEG(Pal2), VARPTR(Pal2), Handle%, 0, 0, 768

  This is same just that it does the inverse. This copies the data from EMS
  to conventional memory.

  Well that's all about moving EMS and conventional memory. In the last
  example that's a waste of memory (allocate 16K of EMS memory to store 768
  bytes!!!) but you can almost store anything that way so you can give it a
  better use.

  You can also move EMS within EMS, you achieve this with the CSMoveEMS sub.

  You call it like :

  CSMoveEMS SHandle%, SLogPage%, SPageOffset%, DHandle%, DLogPage%, DPageOffset%, Length&

  SHandle       is the source handle
  SLogPage      is the source logical page
  SPageOffset   is the offset in the source logical page (remember 0-3FFFh)
  DHandle       is the destiny handle
  DLogPage      is the destiny logical page
  DPageOffset   is the offset in the destiny logical page (remember 0-3FFFh)


  Well, that's all about EMS, hope you did understand :).
  Just in case you didn't understand send me some e-mail and I'll try to
  reply the sooner I can. Look the About section for contacting info.



ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - XMS Memory -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  Introduction  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  This is the almost same as EMS so read the EMS intro.
  The same guys created this system just that this is called XMS or
  Extended Memory System.


ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ
±±  How extended memory works  ±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ


  Unlike EMS, XMS doesn't use a page frame. What this means?
  Well, you can't write directly to XMS. The only way to use it is to copy
  data from conventional memory to XMS and from XMS to conventional memory,
  all this is accomplished with some calls to the XMM (Extended Memory Manager)

  You are probably thinking why the heck should you use XMS instead of EMS,
  well, it has its advantages, like it is faster because the calls to the XMM
  are done directly not with interrupts, you can access 64MB of memory instead
  of 32MB (supposing that the system has such memory, of course!), and the
  memory is allocated and accessed in KB not in 16K pages so you can save a lot
  of memory (If you read the palette example in the EMS section, you know what I
  mean :) ).

  I prefer to use EMS for layers and XMS to store my data, like sprites, tables
  palettes, images, etc.

  A very practical, fast and easy method to do it is, like on the EMS, having
  all your data stored in disk files, when your program begins, load a bunch
  and store it on XMS, load another bit and move onto XMS, and so on till you
  have all your data on XMS and ready to use.

  Let's rewrite the palette example to use XMS instead of EMS, and to load
  more than one palette.

  First, you call CSDetectXMS to see if there is XMS present. You must call
  this function before all other XMS routines because like I said, the XMM
  is called directly and we have to get its address first.

  IF CSDetectXMS = 0 THEN
    PRINT "You need an XMS Manager to run this program!!"
    END
  END IF

  We allocate 1KB of memory

  Handle% = CSAllocateXMS(1)

  We make sure there is a free XMS so our program won't crash.

  IF Handle% = 0 THEN
    PRINT "You need 1K of free XMS to run this program!!"
    END
  END IF

  Now that all it's ok we load our palettes

  DIM Pal AS STRING * 768

  IF CSLoadPal("PALETTE1.PAL", Pal) <> 0 THEN
    PRINT "Could not load PALETTE1.PAL"
    END
  END IF

  Now we move it to XMS

  CSMoveToXMS VARSEG(Pal), VARPTR(Pal), Handle%, 0, 768

  -  First we pass the segment of the palette
  -  Next the offset
  -  Next my XMS Handle
  -  Next the XMS offset. Note that on XMS all the memory is addressed in flat
     model, this means that you reference it with a 32 bits offset and not with
     segment and offsets like normal memory.
  -  And last the length of bytes to copy

  Now we load our second palette in the same variable as the first. (You won't
  lose the first palette, remember that we stored it on XMS)

  IF CSLoadPal("PALETTE2.PAL", Pal) <> 0 THEN
    PRINT "Could not load PALETTE2.PAL"
    END
  END IF

  Now we move it to XMS

  CSMoveToXMS VARSEG(Pal), VARPTR(Pal), Handle%, 768, 768

  You see the difference?
  The only difference is on the XMS offset, it is now 768, why?, because in
  the first 768 bytes is our first palette, and in the next 768 bytes is our
  second one.

  With this example we can use the Pal variable to access all our palettes
  with just 768 bytes of conventional memory. That is, if we have 20 different
  palettes on XMS we can move the one we need into the variable Pal and use it
  in any way and then we can move another into the same variable and so on.

  If we do some math, we realize that we are saving 15K (768 bytes x 20) of
  conventional memory for our other variables!!.

  To recover data from XMS you call CSMoveFromXMS. Let's see it with the
  palettes example.


  CSMoveFromXMS VARSEG(Pal), VARPTR(Pal), Handle%, 0, 768

  This would store our first palette in the Pal variable, just ready to use!!
  To access correctly to  your memory keep and eye on the XMS offset, I'm
  using 768 and multiples of it because the palette format is 768 bytes (refer
  to the Library Format for more info on it) but you have to keep and eye on
  the size of your data so you don't get the wrong data.


  If we want to recover our palette number 15 we do this :

  CSMoveFromXMS VARSEG(Pal), VARPTR(Pal), Handle%, 11004, 768

  Do you got it???


  You can also move data on XMS to XMS, for that you use CSMoveXMS. It's
  format is as follows :


  CSMoveXMS SHandle%, SOffset&, DHandle%, DOffset&, Length&

  Where :

  -  SHandle is the source handle
  -  SOffset is the source offset
  -  DHandle is the destiny handle
  -  DOffset is the destiny offset
  -  Length is the number of bytes to move


*******************************************************************************

  Note: On some implementations of XMS, all the XMS moves, that is, from
        conventional to XMS, from XMS to conventional and from XMS to XMS,
        the length must be even or it won't work. This is not my fault, it is
        of the Extended Memory Manager.

*******************************************************************************


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Blender Maps -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ


  The blender map is just a color table, where the drawing routines that
  support blending look to get the actual color to draw.

  I mean, it takes the combination of foreground (the pixel to draw) and the
  background (the pixel that's already there) colors, and look in the table to
  get the actual color.

  Let's see it with an example:

  First we set mode 13h

  CSInitVGA

  IF CSCreateBMap <> 0 THEN END


  We set our combination so if we draw something of color 1 over color 15,
  instead of drawing all pixels with color 1, the library will draw the
  pixels of color 15 with color 9. Do you get it?

  CSSetBMap 1, 15, 9


  We draw some message on screen

  CSPrint VIDEO, CENTERED, 90, "Blending Example", 15


  And we draw a blended flat-shaded triangle, wait a key press and do the
  closing stuff

  CSTriFB VIDEO, 10, 10, 300, 30, 280, 180, 1
  DO: LOOP WHILE INKEY$ = ""

  CSDestroyBMap
  CSInitText


  If you try this example you will get a simple transparency effect but it
  shows what can be easily done. If you think about it you can see that this
  thing has a lot of potential. You can achieve a lot of cool effects, all
  depends of your imagination.


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Using the timers -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

  NOTE: I tried to make this section as if someone was talking to me =) to
  make it funnier. So every text between [] is as if the guy has talked, any
  other text is me =).

  [Timers, timers, timers...... why do I need a timer ??.]

  Well, think you have coded a game, and it runs fine on your computer, ohh
  it is finished, you say, and suppose you have a 486 machine, do you know
  how it will run on a Pentium ?, what about a Pentium III ?, the game
  will run so fast that it would be unplayable!!!!.

  [Damn, how do I make it to run at the same speed on all machines ??]

  Using a timer !!!!!!

  [But, the system timer runs at 18.2 cycles per second, that sucks !!!]

  Well, CosmoX reprogram this timer to tick every 5 milliseconds.

  [Cool !!!!, but the system time is going to be wrong!!!!]

  Nope, CosmoX keeps tracks of the time and call BIOS to update the time
  when it has to be called.

  [Wow!!!, and how the heck do I use the CosmoX timer ???]

  Keep reading =)

  In fact, it is not a timer, they are sixteen!!!!, with CosmoX you can have
  up to sixteen timers, all at different speeds. The speed ranges between 5
  and 2147483645 milliseconds. When a given timer has reached the limit
  CosmoX updates an internal flag that you can retrieve to know when a given
  timer has ticked, also, the library keeps a counter of how many times a
  given timer has ticked, you can retrieve this value or reset it. You
  can wait for a given timer to tick, too.

  [That's the only use of a timer ???]

  No !, of course it doesn't, you can use a timer for many things, like
  keeping a game timer to kill the user when a limit has passed or give him
  a bonus if he does it in a given time, testing the speed of your code,
  knowing how much time your program has running, the movement of a sprite,
  etc. A timer can be used for many things !!!.

  [Mmmmmm, cool, but is there a limit in the CosmoX timer ?]

  Well, there is one, the CosmoX timer runs at 5 milliseconds, so a user
  timer has to be a multiple of 5.

  [What !!!!!, why the heck did you do it like that ????]

  There is a good reason, as you may know, QB programs only runs on MS-DOS
  and Windows machines, Windows being the most widely used.
  Well, WIndows complains when a DOS program tries to program the timer at
  a fast frequency, it says that the program should run in MS-DOS mode and
  won't let you to run it in a DOS box. (this happens with the DQB timer)

  [God damn Windows!!!!.]

  Yeah, I know it sucks.

  [Enough rambling, I wanna know how to use CosmoX's sixteen timers, I
  wanna see some code!!!]

  Ok, ok, there you go.


  To begin using the timers you need to tell CosmoX, so it can install itself.
  Just put this before using a timer (the timer routines won't work if you
  haven't installed the CosmoX timer):

  CSIntallTimer


  [That's all ???]

  Yeah, but don't forget to tell CosmoX to uninstall its timer before exiting
  your program!!!!

  [How do I do that?]

  Just do this :

  CSRemoveTimer


  [Ok, but how do I access the timers ?]

  Well, let's set a timer to tick every 20 milliseconds to keep the frame
  rate (20 milliseconds is equal to 50 frames per second) and other to
  tick every second. Look at the following code:

  CSSetTimer 0, 20         '  The first timer will tick every 20 milliseconds
  CSSetTimer 1, 1000       '  And the second one every second (1000ms = 1s)


  [Is that easy?]

  Yeah, but note that the first timer is the number 0, and the second is
  number 1, this means that the last one, the 16th one will be number 15.

  [Ohhh I see, they are zero relative, but how do I know when a given timer
  has ticked?]

  Just retrieve the internal timer flag, you do it like this :

  Ticked% = CSTimerFlag(0)  ' This will retrieve the 1st timer flag.


  If CSTimerFlag(WhichTimer%) returns 1 that means that the given timer has
  ticked, 0 otherwise. If you call this function with an invalid timer (like
  16) or a deactivated one it will return zero. So be careful.
  Also, if the given timer has ticked many times and you haven't called this
  function you may skip some ticks.

  [Damn, how can I know if this has happened ?]

  Retrieve the timer counter, this is an internal value that the library
  keeps for every timer. It is incremented when a given timer ticks, so you
  can know how many times a given timer has ticked.

  [Cool, how do I get it ?]

  With the CSEllapsedTicks function, you call it like this :

  Ticks& = CSEllapsedTicks(0)    ' This gets the 1st timer counter


  [Can I reset this value ?]

  Yeah, just call CSResetTicks like this :

  CSResetTicks 0        ' This will reset the 1st timer ticks counter


  [Easy, mmmm, so to make a program run at the same speed in all computers
  I do something like this (at 50 frames per second)]

  [Guy's code :

  CSInstallTimer
  CSSetTimer 0, 20

  DO
    ... do my stuff ...

    WHILE CSTimerFlag(0) <> 1: WEND

    ... do my stuff ...
  LOOP

  CSRemoveTimer

  End of guy's code]


  Yeah, but the library has other sub that helps you on this.

  [Really ??, which one ?, may I see an example ?]

  Sure. Look at this :


  CSInstallTimer
  CSSetTimer 0, 20

  DO
    ... do your stuff ...

    CSWaitTimer 0

    ... do your stuff ...
  LOOP

  CSRemoveTimer


  [That's damn easy !!!]

  Sure it is!!

  [May I see a bigger example ?]

  Look at the library demo, DemoX.

  [Where can I get it ??]

  At CosmoSoft web site : http://cosmosoft.zext.net

  [Ok, so is this the end ???]

  Yeah =( ........


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Using MMX routines -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ

  First, I am going to tell you what is MMX.

  MMX stands for MultiMedia EXtensions, they are 57 new instructions built
  into CPU's newer than Pentium (I guess). (Note, in fact, as new processor
  are released, they get more instructions, but if we go out of this 57
  then we won't run on many machines.)
  Well, the case is that this instructions were made to make multimedia apps
  faster, including graphics applications.

  CosmoX uses this instructions to copy or move data faster than using normal
  instructions, because with MMX CosmoX can copy eight bytes at a time, and
  using normal instructions you can only copy four bytes at a time.

  So, to begin using CosmoX MMX routines you have to tell CosmoX to find out
  if the current CPU supports MMX instructions. You have to call CSDetectMMX
  to accomplish this, like :

  IsMMX% = CSDetectMMX

  IsMMX will have 1 if the CPU supports MMX and zero if not.

  CosmoX has 4 routines that you can use to take advantage of MMX, CSPcopyMMX
  and CSClearMMX. They are commonly used routines.

  CSClearMMX      Clears a layer to a given color (see the routines reference)
  CSPcopyMMX      Copies a layer to other (see the routines reference)
  CSMemCopyMMX    Copies a given number of bytes (see the routines reference)
  CSMemSwapMMX    Swaps a given number of bytes (see the routines reference)

  There are also non-MMX version of this routines (they are here since the
  first version of CosmoX).

  You call the MMX ones the same as the normal ones, but if there is MMX
  present you will get a speed boost.

  If you try to use MMX instructions on CPU's that don't support them, then it
  will crash, but, I coded the routines in a way so they use MMX instructions
  if the CPU supports them or normal instructions if not. So you can call them
  regardless if the processor supports MMX or not. To make this work you have
  to call CSDetectMMX before using any MMX routine, if you fail to do it then
  the library will assume that MMX is not supported and use normal (and slower)
  instructions, so you will miss the speed boost.

  That's all for MMX routines, but I am planning to add more MMX support in
  next versions of CosmoX, even a new matrix calculation module that uses
  fixed point math and MMX routines (damn, that would be fast as hell).

  So enjoy the speed !!


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Library Constants -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ


  To make the use of the library a bit easier, I have included some constants
  representing parameters to the functions. This constants make your source
  code more readable too.

  ⁄ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒø
  ≥ Constant Name   ≥   Value     ≥ Used for                                ≥
  √ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¥
  ≥                 ≥             ≥                                         ≥
  ≥ ATTRIB.READONLY ≥   &H1       ≥ Search for read-only files (CSFindFile) ≥
  ≥ ATTRIB.HIDDEN   ≥   &H2       ≥ Search for hidden files (CSFindFile)    ≥
  ≥ ATTRIB.SYSTEM   ≥   &H4       ≥ Search for system files (CSFindFile)    ≥
  ≥ ATTRIB.VOLLABEL ≥   &H8       ≥ Search for volume label (CSFindFile)    ≥
  ≥ ATTRIB.DIR      ≥   &H10      ≥ Search for directories  (CSFindFile)    ≥
  ≥ ATTRIB.ARCHIVE  ≥   &H20      ≥ Search for archive files (CSFindFile)   ≥
  ≥ CLIPB.TEXT      ≥   &H1       ≥ Windows Clipboard data type (text)      ≥
  ≥ CLIPB.BITMAP    ≥   &H2       ≥ Windows Clipboard data type (bitmap)    ≥
  ≥ CLIPB.META      ≥   &H3       ≥ Windows Clipboard data type (metafile)  ≥
  ≥ CLIPB.SYLK      ≥   &H4       ≥ Windows Clipboard data type (?)         ≥
  ≥ CLIPB.DIF       ≥   &H5       ≥ Windows Clipboard data type (?)         ≥
  ≥ CLIPB.TIFF      ≥   &H6       ≥ Windows Clipboard data type (?)         ≥
  ≥ CLIPB.OEMTEXT   ≥   &H7       ≥ Windows Clipboard data type (oem text)  ≥
  ≥ CLIPB.DIBBITMAP ≥   &H8       ≥ Windows Clipboard data type (dib bitmap)≥
  ≥ CLIPB.DSPTEXT   ≥   &H81      ≥ Windows Clipboard data type (dsp text)  ≥
  ≥ CLIPB.DSPBITMAP ≥   &H82      ≥ Windows Clipboard data type (dsp bitmap)≥
  ≥ BIT.XOR         ≥   0         ≥ Used by CSSpriteO to put in XOR mode    ≥
  ≥ BIT.AND         ≥   1         ≥ Used by CSSpriteO to put in AND mode    ≥
  ≥ BIT.OR          ≥   2         ≥ Used by CSSpriteO to put in OR mode     ≥
  ≥ KEYESC          ≥   1         ≥ Used by the keyboard functions (ESC)    ≥
  ≥ KEYTAB          ≥   &HF       ≥ Used by the keyboard functions (TAB)    ≥
  ≥ KEYENTER        ≥   28        ≥ Used by the keyboard functions (ENTER)  ≥
  ≥ KEYSPACE        ≥   57        ≥ Used by the keyboard functions (SPACE)  ≥
  ≥ KEYUP           ≥   72        ≥ Used by the keyboard functions (UP)     ≥
  ≥ KEYDOWN         ≥   80        ≥ Used by the keyboard functions (DOWN)   ≥
  ≥ KEYLEFT         ≥   75        ≥ Used by the keyboard functions (LEFT)   ≥
  ≥ KEYRIGHT        ≥   77        ≥ Used by the keyboard functions (RIGHT)  ≥
  ≥ ANYKEY          ≥   -1        ≥ Used by the keyboard functions (any key)≥
  ≥ NUM             ≥    0        ≥ Used by CSLockKeys (NUM LOCK)           ≥
  ≥ CAPS            ≥    1        ≥ Used by CSLockKeys (CAPS LOCK)          ≥
  ≥ SCROLL          ≥    2        ≥ Used by CSLockKeys (SCROLL LOCK)        ≥
  ≥ UP              ≥    0        ≥ Used by scrolling routines              ≥
  ≥ DOWN            ≥    1        ≥ Used by scrolling routines              ≥
  ≥ LEFT            ≥    2        ≥ Used by scrolling routines              ≥
  ≥ RIGHT           ≥    3        ≥ Used by scrolling routines              ≥
  ≥ VIDEO           ≥   &HA000    ≥ Contains the video memory segment       ≥
  ≥ CENTERED        ≥   -1        ≥ Used by text routines to center the text≥
  ¿ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒ¡ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒŸ


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Library Types -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ


  - Type Name  -                     - What it is used for -

  TYPE Vector3DType                 This type is used to represent points in
    X AS SINGLE                     3D space, the library routines assume the
    Y AS SINGLE                     variables to be in that order and of that
    Z AS SINGLE                     type (single precision) so don't change
  END TYPE                          them. If you don't know 3D graphics don't
                                    worry about this one.


  TYPE Vector2DType                 This type is used to represent points in
    X AS INTEGER                    2D space (screen and layers), it is used
    Y AS INTEGER                    mainly to store perspective-projected
  END TYPE                          points by the library. Again, don't
                                    change them or it won't work, if you
                                    won't code 3D graphics don't worry about
                                    this one too.


  TYPE WinClipBoardBitMap
    BType           AS INTEGER
    XSize           AS INTEGER
    YSize           AS INTEGER
    BytesPerLine    AS INTEGER      Header of bitmap information when reading
    NumColorPlanes  AS STRING * 1   from the Windows Clipboard, you'll have
    NumAdjColBitsPx AS STRING * 1   to manage header information yourself.
    PtrToData       AS LONG
    XSizeMM         AS INTEGER
    YSizeMM         AS INTEGER
  END TYPE


  TYPE WinClipBoardMetaPic
    MappingMode     AS INTEGER      Header of meta picture information when
    XSize           AS INTEGER      reading from the Windows Clipboard, you'll
    YSize           AS INTEGER      have to manage header information yourself.
  END TYPE

ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Library Formats -  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ


  ---- Palette format ----

  The palette is stored in a 768 characters string, this string holds the hue
  values for each of 256 colors, three bytes per color holding the red, green
  and blue intensities ranging 0-63.


  ---- Font Format ----

  With CosmoX the font is stored in a 2048 characters string, this string holds
  the graphical data of 256 characters, it takes 8 bytes per character
  (8 * 256 = 2048). The character data is encoded in bits, this means that a
  bit in the graphical data represents a pixel in the character. This is, if
  the bit is 1 the pixel is drawn, if is 0 the pixel is not drawn.

  For example the A character is stored like this in the default font:

  00010000 =  &H10             €
  00111000 =  &H38            €€€
  01101100 =  &H6C           €€ €€
  01101100 =  &H6C           €€ €€
  11000110 =  &HC6          €€   €€
  11111110 =  &HFE          €€€€€€€
  11000110 =  &HC6          €€   €€
  00000000 =  &H00


  ---- Mouse cursor format ----

  The mouse cursor is stored in a 64 characters string. This string holds the
  screen and cursor mask of the cursor. The cursor is 16x16 pixels. The first
  32 characters is the screen mask and the last ones the cursor mask. Like the
  font format, a single bit represents a pixel on screen, but here we have two
  masks and we can get four colors with them:

  Bit on screen mask      Bit on cursor mask      Color on screen
          0                      0                    Black
          0                      1                    White
          1                      0                    Transparent
          1                      1                    Inverted


  ---- Blender map format ----

  The blender map it's just a big table holding all color combinations of
  foreground and background colors. To understand the use of this table refer
  to the Blender Map section.


  ---- File format ----

  The palette, font, mouse cursor and blender map files used by CosmoX all have
  a 40 bytes header that contains the library name, the library version and a
  file ID that tells what kind of data this file has stored.

  These are the headers for CosmoX files:


  -- Font --

  "CosmoX Font File    "
  "CosmoX Library v2.0 "  (This may vary due to library version)

  -- Palette --

  "CosmoX Palette File "
  "CosmoX Library v2.0 "   (This may vary due to library version)

  -- Mouse cursor --

  "CosmoX Cursor File  "
  "CosmoX Library v2.0 "   (This may vary due to library version)

  -- Blender map --

  "CosmoX BMap File    "
  "CosmoX Library v2.0 "   (This may vary due to library version)


ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ
≤≤  - Credits and Final words-  ≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤≤
ÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕÕ


  The CosmoX Library has been coded by bobby (bobby3999) from CosmoSoft.

  I hope you enjoy using this library and find it useful, if you have a
  question, bug report, or for any reason you want to contact me, send
  e-mail. See the e-mail address below.

  Special Thanks go to (no special order, except God):

  - Filiberto Cota ----------------------------------------------------------
  Thank you for the many hours we spent in COAPAES, where I did print all the
  tutorials I have, without it, maybe I wouldn't be who I am now.
  ---------------------------------------------------------------------------

  - Michael Abrash ----------------------------------------------------------
  For the bunch of articles I read that were written by him. (They are very
  good, especially the ones about Quake, and 3D animation.)
  ---------------------------------------------------------------------------

  - Denthor (of ASPHIXIA) ---------------------------------------------------
  For his series of tutorials about VGA programming. You really should get
  them, they are a very good introduction for beginners.
  ---------------------------------------------------------------------------

  - Telemachos (from Peroxide Programming Group) ----------------------------
  For his Peroxide programming tips.
  (Despite the little fact that he didn't take in count that you have to
  negate Y when perspective-projecting or the transformations would be wrong,
  and I had to struggle with his normal formulas for this, and I mean it, I
  really had to struggle with this one.)
  ---------------------------------------------------------------------------

  - Vulture (of OUTLAW TRIAD) -----------------------------------------------
  For his tutorial about sound blaster programming. It is very basic but it
  helped me a lot.
  ---------------------------------------------------------------------------

  - Zach Mortensen ----------------------------------------------------------
  For his matrix transformation doc. (Man, you really made me get it, thanks)
  ---------------------------------------------------------------------------

  - Angelo Mottola ----------------------------------------------------------
  For many ideas and because I based some of my code on his (the blender map)
  and I took the ASCII table from his code =)
  ---------------------------------------------------------------------------

  - Danny Gump --------------------------------------------------------------
  Because his library just made me feel like I just have to learn assembly
  and code my own. (Lots of inspiration)
  ---------------------------------------------------------------------------

  - Ralf Brown --------------------------------------------------------------
  For his huge interrupt list (and memory map!). You really must get this
  thing if you want to get deep knowledge about interrupts and DOS hidden
  calls, (I get the Windows interaction info from this thing!).
  ---------------------------------------------------------------------------

  - PCGPE -------------------------------------------------------------------
  As a really great source of information. (Get it!!!)
  ---------------------------------------------------------------------------

  - Tumblin (from Bodies in Motion) -----------------------------------------
  For his texture mapping tutorial.
  ---------------------------------------------------------------------------

  - Chris Egerter -----------------------------------------------------------
  For his Flat, Gouraud shaded and Texture mapped polygons tutorials.
  ---------------------------------------------------------------------------

  - Morten Elling -----------------------------------------------------------
  For his TASM v4.0 and Intel iAPx86 norton guides.
  ---------------------------------------------------------------------------

  - Agner Fong --------------------------------------------------------------
  For his Pentium optimizing doc.
  ---------------------------------------------------------------------------

  - AndrÇ Baresel - Craig Jackson -------------------------------------------
  For their Sound Blaster programming guide. It is a very cool document.
  ---------------------------------------------------------------------------

  - Cesar Rivera ------------------------------------------------------------
  Because he lent me his AMD 386 (and later his Cyrix 686) while I was coding
  CosmoX, I coded CosmoX v1.0 almost entirely on his machines. Now, I am
  designing my site and working on my currents project on his p166. Thanks!.
  ---------------------------------------------------------------------------

  - V1ctor ------------------------------------------------------------------
  Because I learned how to manage the QB string descriptors from his code and
  from a post in www.neozones.com, and also I got the idea of calling QB
  routines from assembly language routines. (CSCreateBMap does this)
  He provided the idea of CSFfix, which is a great routine, thank you dude!
  ---------------------------------------------------------------------------

  - Guy of the Vortex -------------------------------------------------------
  Because his support and because it pointed me a bug in the Sound Blaster
  code (now it's fixed!!!).
  ---------------------------------------------------------------------------

  - Shawn Hargreaves and all the Allegro coders -----------------------------
  Allegro is a very cool DJGPP graphics library, thank to this guys because
  I get the idea of the timers from their library (and because I learned how
  to avoid Windows complains about them).
  ---------------------------------------------------------------------------

  - Rich Geldreich ----------------------------------------------------------
  For the original algorithm used by CSEllipse and CSEllipseF. It was a piece
  of BASIC code that I translated to ASM. No more look-up tables!!!.
  ---------------------------------------------------------------------------

  - ZChip -------------------------------------------------------------------
  Because I learned how to encode MMX instructions using his code.
  ---------------------------------------------------------------------------

  - CGI Joe -----------------------------------------------------------------
  Because I learned how to rotate sprites studying his code.
  ---------------------------------------------------------------------------

  - Lithium -----------------------------------------------------------------
  Because his support and interest into my work. He gave me many ideas and he
  keeps pushing me to improve CosmoX. Also, he is coding the first game using
  CosmoX, the game is XGMAE, it is a very cool game indeed. Also, he always
  points me to bugs on my code, thanks dude! ;)
  ---------------------------------------------------------------------------

  - Jason Gould -------------------------------------------------------------
  Because I realized that I could get my sprite drawing routine much faster,
  studying his code.
  ---------------------------------------------------------------------------

  - Piptol Productions ------------------------------------------------------
  I want to thank this guys for the award they gave me on their site for
  CosmoX v1.7 (a Blue Star!!!). Many thanks, you don't know how proud I feel
  about it. (Maybe a Gold Star for CosmoX v2.0? ;)
  ---------------------------------------------------------------------------

  - Richard Eric M. Lope aka Relsoft(Philippines) ---------------------------
  Thanks for this guy because the nice mails he sent me and his words about
  CosmoX, also, because it really shows the CosmoX power on the brilliant
  game engine he his coding with it. Hope you can get those sprites Eric, and
  that you can finish your game with that awsome engine!.
  ---------------------------------------------------------------------------

  - Mr Moose ----------------------------------------------------------------
  For his constant support and words. Also, he made a very cool game (and
  actually complete!) using CosmoX. I can't wait to see what else you have
  under your sleeve dude!.
  ---------------------------------------------------------------------------

  - NoRy-B ------------------------------------------------------------------
  Again, for his constant support and words.
  He is coding a tanks game with CosmoX (am I wrong?) at the time of this
  writing, and I can't wait to see it finished.
  Thanks for the interest you have on my word Byron, I really appreciate it.
  ---------------------------------------------------------------------------

  - And last but no less important ------------------------------------------
  To all of you who use this library, hey, you can send me some mail or code!
  ---------------------------------------------------------------------------


       If you want to contact me for any reasons send me an e-mail to:

                           bobby3999@yahoo.com

              And don't forget to visit CosmoSoft HomePage at:

                       http://cosmosoft.zext.net


                        Thanks for using CosmoX!!!
